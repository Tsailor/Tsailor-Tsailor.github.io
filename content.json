[{"title":"WebPack系列1：WebPack5搭建React+TS+antd+less开发环境","slug":"Webpack5搭建React+TS+antd+less开发环境","date":"2021-11-16T16:00:00.000Z","updated":"2021-11-18T08:53:28.842Z","comments":true,"path":"2021/11/17/Webpack5搭建React+TS+antd+less开发环境/","link":"","permalink":"http://tsailor.github.io/2021/11/17/Webpack5%E6%90%AD%E5%BB%BAReact+TS+antd+less%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"WebPack 系列 1：WebPack5 搭建 React+TS+antd+less 开发环境一直以来使用 React 开发项目都是使用脚手架 umi,这次试试使用 WebPack5 搭建 React+TS+antd+less 开发环境。 项目初始化新建文件夹并进入此文件夹，打开命令工具(cmd / git bash)yarn init -y Webpackyarn add webpack webpack-cli -D webpack-cli提供了许多命令来使 webpack 的工作变得更简单 本文安装的版本是 12\"webpack\": \"^5.64.1\",\"webpack-cli\": \"^4.9.1\" 创建 Webpack 配置文件webpack.config.js配置基本内容","text":"WebPack 系列 1：WebPack5 搭建 React+TS+antd+less 开发环境一直以来使用 React 开发项目都是使用脚手架 umi,这次试试使用 WebPack5 搭建 React+TS+antd+less 开发环境。 项目初始化新建文件夹并进入此文件夹，打开命令工具(cmd / git bash)yarn init -y Webpackyarn add webpack webpack-cli -D webpack-cli提供了许多命令来使 webpack 的工作变得更简单 本文安装的版本是 12\"webpack\": \"^5.64.1\",\"webpack-cli\": \"^4.9.1\" 创建 Webpack 配置文件webpack.config.js配置基本内容 12345678910111213const path = require(\"path\");module.exports = &#123; mode: \"development\", // 指定 development(开发环境) 和 production(生产环境) entry: &#123; index: \"./src/index.js\", // 项目入口 &#125;, output: &#123; filename: \"[name].bundle.js\", // 输出文件名 path: path.resolve(__dirname, \"dist\"), // 路径 clean: true, // 打包清除缓存 &#125;,&#125;; React安装 React、ReactDomyarn add react react-dom -S安装解析 ES6 和 JSX 语法的 Babelbabel-loader@7+ 对应的版本都更名（以前是 xx-yy-zz的格式） @babel/core @babel/preset-env @babel/preset-reactyarn add @babel/core babel-loader @babel/preset-env @babel/preset-react -D根目录下创建.babelrc 文件，并写入 123456&#123; \"presets\": [ \"@babel/preset-env\", \"@babel/preset-react\" ]&#125; 配置 Webpack安装开发服务器yarn add webpack-dev-server -D配置 devtool 和 devServer 12345678910// ... 省略其他module.exports = &#123; // ... 省略其他 devtool: \"inline-source-map\", devServer: &#123; static: \"./dist\", port: \"3001\", &#125;,&#125;; 安装插件 HtmlWebpackPlugin, 并且调整 webpack.config.js 文件：yarn add html-webpack-plugin -D 并配置 babel-loader 1234567891011121314151617181920const path = require(\"path\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = &#123;&#123; // ... 省略其他 plugins: [ new HtmlWebpackPlugin(&#123; title: 'React——New Test', &#125;), ], module: &#123; rules: [ &#123; test: /\\.(js|jsx)?$/, // 处理以.js|.jsx结尾的文件 exclude: /node_modules/, // 处理除了nodde_modules里的js文件 loader: \"babel-loader\", // 用babel-loader处理 &#125; ],&#125; 配置 Npm Script在 package.json 中 1234\"scripts\": &#123; \"build\": \"webpack\", \"start\": \"webpack serve --open\"&#125;, 配置 HTML 模板新建 public 文件夹加入 Html 文件 、favicon 图标index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 更新 HtmlWebpackPlugin 的配置 12345678910module.export = &#123; // ... 省略其他 plugins: [ new HtmlWebpackPlugin(&#123; title: \"React——NEW Test\", template: \"public/index.html\", favicon: \"public/favicon.png\", &#125;), ],&#125;; 写入 React 项目代码新建 src 文件夹，新建 index.js 文件作为项目入口写入 1234567import React from \"react\";import ReactDOM from \"react-dom\";const App = () =&gt; &#123; return &lt;div&gt;hello,world&lt;/div&gt;;&#125;;ReactDOM.render(&lt;App /&gt;, document.querySelector(\"#root\")); 运行终端输入命令 yarn start,如果项目跑起来了则一切正常 使用 less 文件安装插件 mini-css-extract-plugin， 将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件安装 css-loader、less-loader 并开启模块化 yarn add mini-css-extract-plugin css-loader less less-loader -D 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const path = require(\"path\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");module.exports = &#123; // ...省略 plugins: [ new HtmlWebpackPlugin(&#123; title: \"React——NEW Test\", template: \"public/index.html\", favicon: \"public/favicon.png\", &#125;), new MiniCssExtractPlugin(), ], module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, // 处理以.js|.jsx结尾的文件 exclude: /node_modules/, // 处理除了nodde_modules里的js文件 loader: \"babel-loader\", // 用babel-loader处理 &#125;, &#123; test: /\\.css$/i, use: [ MiniCssExtractPlugin.loader, &#123; loader: \"css-loader\", options: &#123; modules: true, &#125;, &#125;, ], &#125;, &#123; test: /\\.less$/i, use: [ MiniCssExtractPlugin.loader, &#123; loader: \"css-loader\", options: &#123; modules: true, &#125;, &#125;, &#123; loader: \"less-loader\", &#125;, ], &#125;, ], &#125;,&#125;; 安装 TypeScript 添加 React 和 React-DOM 的声明文件yarn add @types/react @types/react-dom -D 添加 TypeScript 的依赖 ,特别注意不要使用 awesome-typescript-loader , 这个已经淘汰了和新的很多 库不兼容，例如 antd.使用这个babel-loader @babel/preset-typescript yarn add typescript @babel/preset-typescript source-map-loader -D 添加 TypeScript 配置文件新建 tsconfig.json 文件 写入 123456789101112131415&#123; \"compilerOptions\": &#123; \"outDir\": \"./dist/\", \"sourceMap\": true, \"noImplicitAny\": true, \"module\": \"commonjs\", \"target\": \"es5\", \"jsx\": \"react\", \"allowJs\": false, \"allowSyntheticDefaultImports\": true, \"esModuleInterop\": true &#125;, \"include\": [\"./src/**/*\"], \"exclude\": [\"node_modules\"]&#125; 关于allowSyntheticDefaultImports见这里 由 allowSyntheticDefaultImports 引起的思考 再配置 .babelrc文件。 1234567&#123; \"presets\": [ \"@babel/preset-env\", \"@babel/preset-react\", \"@babel/preset-typescript\" // 新增一行 ]&#125; 再修改 配置 webpack.config.js文件。 1234567 // ... 省略 &#123; test: /\\.(ts|tsx|js|jsx)$/, exclude: /node_modules/, // 处理除了nodde_modules里的js文件 loader: \"babel-loader\", // 用babel-loader处理 &#125;, // 省略 将 index.js 以及 webpack 的入口都修改为 index.tsx。如果有引入 css/less 图片等内容的话然后发现 index.tsx 里 import 语句有报错。Cannot find module &#39;./styles.less&#39; or its corresponding type declarations.ts(2307) 在 typescript 中是无法识别非代码资源的，所以会报错 TS2307: cannot find module ‘.png’。因此，我们需要主动的去声明这个 module。新建一个 ts 声明文件 src 目录下，新建 type.d.ts,并写入 12345678910declare module \"*.svg\";declare module \"*.png\";declare module \"*.jpg\";declare module \"*.jpeg\";declare module \"*.gif\";declare module \"*.bmp\";declare module \"*.tiff\";declare module \"*.less\";declare module \"*.css\"; 运行一下，看看效果 使用Antd安装antd组件库，并开启按需加载 12yarn add antd -Syarn add babel-plugin-import -D 配置.babelrc文件 1234567891011121314&#123; // ...省略 // 新增以下内容 \"plugins\": [ [ \"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"lib\", \"style\": true &#125; ] ]&#125; 关于配置、总共有三种配置代码 [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot; }]：引入的是 js 模块 [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: true }]：引入的是 less 文件，需要在 webpack.config.js 额外配置 less-loader 等，且不能在 module.rules 中把 node_modules/antd 给 exclude 了，如下操作 [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: css }]：引入的是 css 文件，需要在 webpack.config.js 额外配置 css-loader 等，且不能在 module.rules 中把 node_modules/antd 给 exclude 开启了CSS 模块化后，和antd的按需加载 发生冲突，导致样式无效 利用 exclude: /node_modules/, 分开配置，在webpack.config.js中修改配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; test: /\\.css$/i, exclude: /node_modules/, use: [ MiniCssExtractPlugin.loader, &#123; loader: \"css-loader\", options: &#123; modules: true, importLoaders: 1, &#125;, &#125;, ],&#125;,&#123; test: /\\.less$/, // node_modules中的内容关闭模块化 exclude: [/src/], use: [ MiniCssExtractPlugin.loader, &#123; loader: \"css-loader\", options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: \"less-loader\", options: &#123; lessOptions: &#123; javascriptEnabled: true, &#125;, &#125;, &#125;, ],&#125;,&#123; test: /\\.less$/i, exclude: /node_modules/, // src中的内容关闭模块化 use: [ MiniCssExtractPlugin.loader, &#123; loader: \"css-loader\", options: &#123; modules: true, importLoaders: 1, &#125;, &#125;, &#123; loader: \"less-loader\", &#125;, ],&#125;, 然后运行 npm start, 可能会遇到这个错误, “内联JavaScript没有启用。”这是less的问题，在less低版本里没有这个问题 12345678ERROR in .&#x2F;node_modules&#x2F;antd&#x2F;es&#x2F;button&#x2F;style&#x2F;index.less (.&#x2F;node_modules&#x2F;antd&#x2F;es&#x2F;button&#x2F;style&#x2F;index.less.webpack[javascript&#x2F;auto]!&#x3D;!.&#x2F;node_modules&#x2F;css-loader&#x2F;dist&#x2F;cjs.js??ruleSet[1].rules[2].use[1]!.&#x2F;node_modules&#x2F;less-loader&#x2F;dist&#x2F;cjs.js!.&#x2F;node_modules&#x2F;antd&#x2F;es&#x2F;button&#x2F;style&#x2F;index.less)Module build failed (from .&#x2F;node_modules&#x2F;less-loader&#x2F;dist&#x2F;cjs.js):&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;ant-design&#x2F;ant-motion&#x2F;issues&#x2F;44.bezierEasingMixin();^Inline JavaScript is not enabled. Is it set in your options? 解决方式, 在less-loader中加入配置，允许javascript 1234567 &#123; loader: &quot;less-loader&quot;, options:&#123; lessOptions:&#123; javascriptEnabled:true &#125;&#125;, 如果你遇到了这个问题，那也是因为你webpack.config.js 的antd 没有分开配置 1234ERROR in .&#x2F;node_modules&#x2F;antd&#x2F;lib&#x2F;style&#x2F;index.less 1:0Module parse failed: Unexpected character &#39;@&#39; (1:0)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https:&#x2F;&#x2F;webpack.js.org&#x2F;concepts#loaders&gt; @import &#39;.&#x2F;themes&#x2F;index&#39;; 至此，WebPack5 搭建 React+TS+antd+less 开发环境 暂且完成。 愿天堂没有配置⛺⛺⛺⛺⛺⛺⛺⛺⛺⛺⛺⛺⛺⛺ 附录一.webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105const path &#x3D; require(&quot;path&quot;);const HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin &#x3D; require(&quot;mini-css-extract-plugin&quot;);module.exports &#x3D; &#123; mode: &quot;development&quot;, entry: &#123; index: &quot;.&#x2F;src&#x2F;index.tsx&quot;, &#125;, output: &#123; filename: &quot;[name].bundle.js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), clean: true, &#x2F;&#x2F;清理 &#x2F;dist 文件夹 &#125;, devtool: &quot;inline-source-map&quot;, resolve: &#123; &#x2F;&#x2F; Add &#39;.ts&#39; and &#39;.tsx&#39; as resolvable extensions. extensions: [&quot;.ts&quot;, &quot;.tsx&quot;, &quot;.js&quot;, &quot;.json&quot;], &#125;, devServer: &#123; static: &quot;.&#x2F;dist&quot;, port: &quot;3001&quot;, open: false, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: &quot;React——NEW Test&quot;, template: &quot;public&#x2F;index.html&quot;, favicon: &quot;public&#x2F;favicon.png&quot;, &#125;), new MiniCssExtractPlugin(), ], module: &#123; rules: [ &#123; test: &#x2F;\\.(ts|tsx|js|jsx)$&#x2F;, exclude: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 处理除了nodde_modules里的js文件 loader: &quot;babel-loader&quot;, &#x2F;&#x2F; 用babel-loader处理 &#125;, &#123; test: &#x2F;\\.css$&#x2F;i, exclude: &#x2F;node_modules&#x2F;, use: [ MiniCssExtractPlugin.loader, &#123; loader: &quot;css-loader&quot;, options: &#123; modules: true, importLoaders: 1, &#125;, &#125;, ], &#125;, &#123; test: &#x2F;\\.less$&#x2F;, &#x2F;&#x2F; node_modules中的内容关闭模块化 exclude: [&#x2F;src&#x2F;], use: [ MiniCssExtractPlugin.loader, &#123; loader: &quot;css-loader&quot;, options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: &quot;less-loader&quot;, options: &#123; lessOptions: &#123; javascriptEnabled: true, &#125;, &#125;, &#125;, ], &#125;, &#123; test: &#x2F;\\.less$&#x2F;i, exclude: &#x2F;node_modules&#x2F;, use: [ MiniCssExtractPlugin.loader, &#123; loader: &quot;css-loader&quot;, options: &#123; modules: true, importLoaders: 1, &#125;, &#125;, &#123; loader: &quot;less-loader&quot;, options: &#123; lessOptions: &#123; javascriptEnabled: true, &#125;, &#125;, &#125;, ], &#125;, &#123; test: &#x2F;\\.(png|svg|jpg|jpeg|gif)$&#x2F;i, type: &quot;asset&#x2F;resource&quot;, &#125;, ], &#125;,&#125;;","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"http://tsailor.github.io/tags/tools/"},{"name":"webpack","slug":"webpack","permalink":"http://tsailor.github.io/tags/webpack/"}]},{"title":"记录一次Typescript+Axios的使用","slug":"记录一次Typescript+Axios的使用","date":"2021-10-25T16:00:00.000Z","updated":"2021-10-26T10:11:31.002Z","comments":true,"path":"2021/10/26/记录一次Typescript+Axios的使用/","link":"","permalink":"http://tsailor.github.io/2021/10/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Typescript+Axios%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"在使用typescript中使用axios时，很多资料都是用any来处理返回值得类型 于是，记录一次Typescript+Axios的使用","text":"在使用typescript中使用axios时，很多资料都是用any来处理返回值得类型 于是，记录一次Typescript+Axios的使用 axios封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import &#123; notification &#125; from 'antd';import axios from 'axios';const codeMessage: Record&lt;number, string&gt; = &#123; 200: '服务器成功返回请求的数据。', 201: '新建或修改数据成功。', 202: '一个请求已经进入后台排队（异步任务）。', 204: '删除数据成功。', 400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。', 401: '用户没有权限（令牌、用户名、密码错误）。', 403: '用户得到授权，但是访问是被禁止的。', 404: '发出的请求针对的是不存在的记录，服务器没有进行操作。', 406: '请求的格式不可得。', 410: '请求的资源被永久删除，且不会再得到的。', 422: '当创建一个对象时，发生一个验证错误。', 500: '服务器发生错误，请检查服务器。', 502: '网关错误。', 503: '服务不可用，服务器暂时过载或维护。', 504: '网关超时。',&#125;;// /**// * @zh-CN 异常处理程序// * @en-US Exception handler// */const errorHandler = (error: &#123; response: Response &#125;) =&gt; &#123; const &#123; response &#125; = error; if (response &amp;&amp; response.status) &#123; const errorText = codeMessage[response.status] || response.statusText; const &#123; status, url &#125; = response; notification.error(&#123; message: `Request error $&#123;status&#125;: $&#123;url&#125;`, description: errorText, &#125;); &#125; else if (!response) &#123; notification.error(&#123; description: 'Your network is abnormal and cannot connect to the server', message: 'Network anomaly', &#125;); &#125; // return response; return Promise.reject(error);&#125;;var Request = axios.create(&#123; headers: &#123; 'Content-Type': 'application/json' &#125;, &#125;);// 添加请求拦截器Request.interceptors.request.use( function (config) &#123; const token = localStorage.getItem('rpa-token'); if (token) &#123; // @ts-ignore config.headers.common['token'] = token; &#125; return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;,);// 添加响应拦截器Request.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 /** 1、集中处理响应数据（如错误码处理） */ // console.log('Request.interceptors.response', response.data); return response;&#125;, errorHandler);export default Request; 使用 12345678910111213141516171819202122import &#123; AxiosResponse &#125; from 'axios';import &#123; LoginParams &#125; from './index';import request from './request';type AxiosResponseType&lt;T&gt; = Promise&lt;AxiosResponse&lt;Body&lt;T&gt;&gt; &gt;type Body&lt;T&gt; = &#123; code:number; data:T; message:string&#125;// 实际内容type User = &#123; name:string; token:string; avtor:string; &#125;export const login = (params: LoginParams):AxiosResponseType&lt;User&gt; =&gt; &#123; return request('/api/login', &#123; method: 'POST', data: params, &#125;);&#125;;","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://tsailor.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"前端ArrayBuffer和String、Blob和DataUrl的相互转换","slug":"前端ArrayBuffer和String、Blob和DataUrl的相互转换","date":"2021-09-07T16:00:00.000Z","updated":"2021-09-09T08:08:54.777Z","comments":true,"path":"2021/09/08/前端ArrayBuffer和String、Blob和DataUrl的相互转换/","link":"","permalink":"http://tsailor.github.io/2021/09/08/%E5%89%8D%E7%AB%AFArrayBuffer%E5%92%8CString%E3%80%81Blob%E5%92%8CDataUrl%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/","excerpt":"在之前写公司的业务的时候有这样的一个需求，通过 XMLHttpRequest 拿到图片的二进制内容。然后将 ArrayBuffer 中的数据暂存在 JSON 中，所以需要涉及到 ArrayBuffer 和 String 的相互转换。记录一下 1234567891011121314151617/** * @description 将ArrayBuffer对象转换成string * @param &#123;ArrayBuffer&#125; buf - ArrayBuffer对象 */function bufferToString(buf): Promise&lt;string&gt; &#123; return new Promise((resolve) =&gt; &#123; var blob = new Blob([buf], &#123; type: \"application/octet-stream\" &#125;); var reader = new FileReader(); reader.onload = function (event) &#123; const result = event.target.result as string; // console.log(\"result\",result); resolve(result); &#125;; reader.readAsText(blob, \"utf-8\"); &#125;);&#125;","text":"在之前写公司的业务的时候有这样的一个需求，通过 XMLHttpRequest 拿到图片的二进制内容。然后将 ArrayBuffer 中的数据暂存在 JSON 中，所以需要涉及到 ArrayBuffer 和 String 的相互转换。记录一下 1234567891011121314151617/** * @description 将ArrayBuffer对象转换成string * @param &#123;ArrayBuffer&#125; buf - ArrayBuffer对象 */function bufferToString(buf): Promise&lt;string&gt; &#123; return new Promise((resolve) =&gt; &#123; var blob = new Blob([buf], &#123; type: \"application/octet-stream\" &#125;); var reader = new FileReader(); reader.onload = function (event) &#123; const result = event.target.result as string; // console.log(\"result\",result); resolve(result); &#125;; reader.readAsText(blob, \"utf-8\"); &#125;);&#125; 1234567891011121314151617/** * @description 将string转换成ArrayBuffer * @param &#123;string&#125; str - 参数string */function stringToBuffer(str): Promise&lt;ArrayBuffer&gt; &#123; return new Promise((resolve) =&gt; &#123; var blob = new Blob([str], &#123; type: \"text/plain\" &#125;); var reader = new FileReader(); reader.onload = function (event) &#123; const result = event.target.result as ArrayBuffer; // console.log(\"result\",result); resolve(result); &#125;; reader.readAsArrayBuffer(blob); &#125;);&#125; 但是问题并没有完全解决，原因大概是，图片二进制内容 ArrayBuffer 转换成 string 类型，通过 utf-8 编码生成的乱码，再转换回去时候，二进制数据内容和长度发生了变化。于是，我结合另一个情景，前端图片经常使用 DataUrl 表示(DataUlr 使用的也就是 Base64 编码)，所以我把图片转成成 DataUrl，保存的时候存下这个 DataUrl,使用的时候再转换成二进制内容。于是， 设置 XMLHttpRequest.responseType = &#39;blob&#39;;然后问题就变成了 Blob 与 DataUrl 的转换 1234567891011121314151617181920212223242526272829303132333435/** * @description 将blob转换成DataUrl * @param &#123;Blob&#125; blob - blob */function blobToDataUrl(blob: Blob): Promise&lt;string&gt; &#123; return new Promise((resolve) =&gt; &#123; var reader = new FileReader(); reader.onload = function (event) &#123; const result = event.target.result as string; // console.log(\"result\",result); resolve(result); &#125;; reader.readAsDataURL(blob); &#125;);&#125;/** * @description 将DataUrl转换成Blob * @param &#123;string&#125; dataurl - 参数dataurl （base64编码） */function dataUrlToBlob(dataurl: string): Promise&lt;Blob&gt; &#123; return new Promise((resolve) =&gt; &#123; var arr = dataurl.split(\",\"), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; let blob = new Blob([u8arr], &#123; type: mime &#125;); resolve(blob); &#125;);&#125;","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://tsailor.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"如何实现useState改变值之后立刻获取最新的状态","slug":"如何实现useState改变值之后立刻获取最新的状态","date":"2021-09-01T16:00:00.000Z","updated":"2021-09-02T09:34:31.294Z","comments":true,"path":"2021/09/02/如何实现useState改变值之后立刻获取最新的状态/","link":"","permalink":"http://tsailor.github.io/2021/09/02/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0useState%E6%94%B9%E5%8F%98%E5%80%BC%E4%B9%8B%E5%90%8E%E7%AB%8B%E5%88%BB%E8%8E%B7%E5%8F%96%E6%9C%80%E6%96%B0%E7%9A%84%E7%8A%B6%E6%80%81/","excerpt":"如何实现 useState 改变值之后立刻获取最新的状态之前在写项目的时候,遇到一个问题,如何实现 useState 改变值之后立刻获取最新的状态?然后刚刚好在思否上看到一个大神操作方法记录一下原文连接","text":"如何实现 useState 改变值之后立刻获取最新的状态之前在写项目的时候,遇到一个问题,如何实现 useState 改变值之后立刻获取最新的状态?然后刚刚好在思否上看到一个大神操作方法记录一下原文连接 因为在 react 合成事件中改变状态是异步的，出于减少 render 次数，react 会收集所有状态变更，然后比对优化，最后做一次变更 1234567891011121314151617181920212223242526/* * @lastTime: 2021-03-05 15:29:11 * @Description: 同步hooks */import &#123; useEffect, useState, useCallback &#125; from \"react\";const useSyncCallback = (callback) =&gt; &#123; const [proxyState, setProxyState] = useState(&#123; current: false &#125;); const Func = useCallback(() =&gt; &#123; setProxyState(&#123; current: true &#125;); &#125;, [proxyState]); useEffect(() =&gt; &#123; if (proxyState.current === true) setProxyState(&#123; current: false &#125;); &#125;, [proxyState]); useEffect(() =&gt; &#123; proxyState.current &amp;&amp; callback(); &#125;); return Func;&#125;;export default useSyncCallback; 使用示例 12345678910111213141516171819202122function App() &#123; const [state, setstate] = useState(0); const setT = () =&gt; &#123; setstate(2); func(); &#125;; /** 将func的方法传递给useSyncCallback然后返回一个新的函数 */ const func = useSyncCallback(() =&gt; &#123; console.log(state); &#125;); return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;button onClick=&#123;setT&#125;&gt;set 2&lt;/button&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://tsailor.github.io/tags/React/"}]},{"title":"关于Promise.all的并发控制","slug":"关于Promise.all的并发控制","date":"2021-08-29T16:00:00.000Z","updated":"2021-08-30T02:53:09.977Z","comments":true,"path":"2021/08/30/关于Promise.all的并发控制/","link":"","permalink":"http://tsailor.github.io/2021/08/30/%E5%85%B3%E4%BA%8EPromise.all%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/","excerpt":"在前端同时处理多个Http请求时，为了减少请求与响应时延，往往会使用Promise.all()实现请求并行发送。但是浏览器对此有一定的限制，在 Chrome 浏览器中允许的最大并发请求数目为 6，这个限制还有一个前提是针对同一域名的，超过这一限制的后续请求将会被阻塞。 于是，可以通过一定方式实现并发控制，一次发送一组Http请求，待执行完成一个Http请求则将下一个Http请求加入分组","text":"在前端同时处理多个Http请求时，为了减少请求与响应时延，往往会使用Promise.all()实现请求并行发送。但是浏览器对此有一定的限制，在 Chrome 浏览器中允许的最大并发请求数目为 6，这个限制还有一个前提是针对同一域名的，超过这一限制的后续请求将会被阻塞。 于是，可以通过一定方式实现并发控制，一次发送一组Http请求，待执行完成一个Http请求则将下一个Http请求加入分组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @description Promsie.all()并发控制 * @param &#123;Array&lt;() =&gt; Promise&lt;any&gt;&gt;&#125; request - 异步事件组成的数组，每个元素执行后会返回一个Promise对象 * @param &#123;number&#125; max - 最大并发控制数 * @param &#123;() =&gt; Promise&lt;any&gt;&#125; callback - 批量执行完成回调函数*/export const handleBatchRequest = (request:Array&lt;() =&gt; Promise&lt;any&gt;&gt;, max = 6, callback: () =&gt; Promise&lt;any&gt;) =&gt; &#123; let i = 0; // 数组下标 已经执行过或者正在执行 的个数 let okCount = 0; // 执行完成的个数 let fetchArr: Promise&lt;any&gt;[] = []; // 正在执行的请求 let len = request.length; let toFetch = (): Promise&lt;any&gt; =&gt; &#123; // 如果异步任务都已开始执行，剩最后一组，则结束并发控制 if (i === len) &#123; return Promise.resolve(); &#125; // 执行异步任务 let it = request[i](); i++; // 添加异步事件的完成处理 it.then(() =&gt; &#123; okCount++; fetchArr.splice(fetchArr.indexOf(it), 1); &#125;).catch((err) =&gt; &#123; // 添加异步事件的错误处理 console.log('error', err); // 结束 toFetch return Promise.reject(err); &#125;); fetchArr.push(it); let p = Promise.resolve(); // 如果并发数达到最大数，则等其中一个异步任务完成再添加 if (fetchArr.length &gt;= max) &#123; p = Promise.race(fetchArr); &#125; // 执行递归 return p.then(() =&gt; toFetch()); &#125;; toFetch() .then(() =&gt; // 最后一组全部执行完再执行回调函数 Promise.all(fetchArr).then(() =&gt; &#123; // 执行全部成功的回调函数 callback(); &#125;), ) .catch(() =&gt; &#123; // todo： 错误处理 &#125;);&#125;;","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://tsailor.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"前端面试题--某易26问","slug":"前端面试题--某易26问","date":"2020-10-10T16:00:00.000Z","updated":"2021-08-27T01:49:52.533Z","comments":true,"path":"2020/10/11/前端面试题--某易26问/","link":"","permalink":"http://tsailor.github.io/2020/10/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98--%E6%9F%90%E6%98%9326%E9%97%AE/","excerpt":"前端面试题–某易26问1、介绍redux，主要解决什么问题答：redux ：可预测的状态管理机，随着单页面应用的需求越来越复杂，组件间的数据传递和状态管理越来越复杂。Redux 通过一系列约定的规范将修改应用的状态标准化，Redux应用需要遵循三大原则：1，唯一数据源 2，保持应用状态只读 3，应用状态的修改要通过纯函数来完成。Redux主要用来解决大型web项目间复杂数据传递与状态管理的问题。 2、⽂件上传如何做断点续传","text":"前端面试题–某易26问1、介绍redux，主要解决什么问题答：redux ：可预测的状态管理机，随着单页面应用的需求越来越复杂，组件间的数据传递和状态管理越来越复杂。Redux 通过一系列约定的规范将修改应用的状态标准化，Redux应用需要遵循三大原则：1，唯一数据源 2，保持应用状态只读 3，应用状态的修改要通过纯函数来完成。Redux主要用来解决大型web项目间复杂数据传递与状态管理的问题。 2、⽂件上传如何做断点续传 答： a.将文件切片上传，每片都带有一个hash值+下标，然后并发向后端发送b.后端将文件切片存储在临时文件夹里c.断点续传时，向服务器端请求，返回后端已经接受完毕的分片d.前端重新发送切片，并跳过已经发送完毕的切片e.所有分片发送完毕，前端发送请求告知分片发送完毕，后端组合分片 3、表单可以跨域吗答：可以，跨域限制是浏览器为了安全和隐私机制设定的限制。Form表单提交数据，请求到了另一个域里，原页面的脚本无法获取新页面里的内容，Form表单会刷新页面也不会把返回结果给js，所以浏览器认为安全。 4、promise、async有什么区别答：a.promise和async都能够解决异步任务的顺序问题，但是promise是通过链式调用来完成的，而async/await能使异步任务的写法像同步任务一样 b.async 后接一个函数，函数的返回值就是一个成功状态的promise对象 5、搜索请求如何处理（防抖）答：监听输入框的onChange事件，做防抖处理，在onChange触发后一定时间间隔内没有再次触发，则发起Ajax请求。 #####6、搜索请求中⽂如何请求 #####答：a.调用js方法encodeURI，将url编码，然后请求b. 修改服务器编码集,设置为 utf-8 7、介绍观察者模式答：观察者模式是指对象间存在一对多的依赖关系，当一个对象的状态改变后，所有依赖他的对象都得到通知并自动更新。观察者模式是一种对象行为模型，优点：1.降低了目标和观察者之间的耦合关系，两者之间是抽象耦合关系2.目标与观察者之间建立了一种触发机制缺点：1.目标和观察者之间的依赖关系并没有完全解除2.观察者对象很多时，通知的发布会花费很多时间 8、观察者和订阅-发布的区别，各⾃⽤在哪⾥？ 答：订阅-发布模式里，发布者向某个信道发布一条消息，订阅者绑定这个信道，当有消息发布至信道就会接收一条通知。区别：订阅-发布模式，是完全解耦的，两者仅共享一个信道；观察者模式是抽象耦合关系，不完全解耦。观察者模式，多应用于单个应用内部发布-订阅模式，多应用于跨应用模式 9、介绍中介者模式答：中介者模式，定义一个中介对象来封装一系列对象的交互，使原有对象之间的耦合松散，且可以独立改变他们之间的交互，又被称作调停模式。中介者模式是一种对象行为模式，优点：降低了对象之间的耦合，使得对象能够独立被复用。将对象之间的一对多关联转变成一对一关联，提升系统灵活性。 10、介绍react优化答：1.减少不必要渲染a 使用key值b 类组件里继承自pureComponent，函数组件使用React.memo 包裹c 分别使用useMemo和useCallback 分别缓存值和函数d.使用shouldComponentUpdate阻止不必要的渲染2.使用React.Fragment 来避免向 DOM 添加额外的节点3.使用 React.Lazy 延迟加载组件，实现组件的按需加载。即动态调用import()4.长列表优化，懒加载+分页 或者 虚拟列表 11、介绍http2.0 答：1.二进制分帧。在应用层和运输层之间添加了一个二进制分帧层，将传输信息分成更小的消息和帧，并对他们实现二进制格式编码运输，改进传输性能。2.多路复用。意味着很多流的数据包能混合在一起通过同一条tcp连接上传输，实现真正的并行传输3.压缩首部。压缩报文首部减少传输大小，并缓存首部避免重复的首部传输。4.服务器推送 12、通过什么做到并发请求？答：Promise.all([p1, p2, p3]).then(res =&gt;{}) 13、http1.1是如何复⽤TCP连接？答：http1.1里通过设置报文首部行字段 connection：keep-alive来实现连接复用，使得可以在一条TCP 连接上完成所有的http请求。 14、介绍service worker略 15、介绍css3中position:sticky答：position：sticky又称粘性布局。以top,left,right,bottom为阈值，超过阈值表现为相对定位，反之，表现为相对于父元素的固定定位。 16、使用Redux请求中间件如何处理并发?答：使用redux-thunk中间件，使得dispatch()里能接收一个内含有异步操作的函数，这个异步函数里使用promise发出请求，然后使用Promise.all([p1,p2])处理并发,拿到所有成功状态下的返回结果。 17、介绍Promise，异常捕获答：Promise是异步编程解决方案之一，Promise是一个容器保存着异步操作的结果。Promise对象有三种状态，pending(进行中)，resolved(已成功)，rejected(已失败)。通过new Promise((resolve, rejecte)=&gt;{})来构造Promise对象的实例，传入函数作为参数，当异步任务执行成功调用resolve(res)送出返回值，失败则调用reject()抛出异常。通过链式调用(也就是实例对象调用then())接收成功状态的返回值或接收异常，再次返回一个Promise对象的实例。Promise.prototype.catch()用来捕捉异常，实际上也就then(null,(error)=&gt;{})的变形。 18、介绍position属性包括CSS3新增position:fixed,固定定位,相对于屏幕视口布局，元素从正常文档流中移除。position:static,静态定位(默认)，处于正常文档流中，top right bottom left不会生效。position:relative,相对定位，元素相对于正常文档流中的位置发生偏移，且占据原来的位置(原位置会留白)。position:absolute,绝对定位，元素相对于最近的非static定位的祖先元素发送偏移，且从文档流中移除。position：sticky又称粘性布局。以top,left,right,bottom为阈值，超过阈值表现为相对定位，反之，表现为相对于父元素的固定定位。 19、浏览器事件流向答：浏览器事件流向分为两个阶段，捕获和冒泡。捕获阶段是指触发事件先从Dom树的根节点触发(也就是document)，向下层层传递到执行事件的目标节点。冒泡阶段是指从Dom树的子节点，也就是从目标节点向上传递到document。不冒泡事件如blur,focus，mouseenter，mouseleave等是在捕获阶段触发，冒泡事件默认是在冒泡阶段触发。 20、介绍事件代理以及优缺点答：事件代理是指将事件的触发及触发执行函数绑定在祖先元素上，触发事件时向上冒，由祖先元素代为执行。优点：1、避免给每一个子元素都绑定同一类型的事件，代码清晰，结构优雅。2、方便动态删除元素时，内存泄漏问题。3、降低js与Dom的耦合程度。缺点：如果所有的事件都使用事件代理时，容易形成误判？但我觉得通过自定义属性可以避免? 21、React组件中怎么做事件代理？答：React基于virtual Dom 实现了一个SyntheticEvent(合成事件层)，我们定义的事件处理器会接收一个SyntheticEvent对象的实例，这个实例符合W3C的标准，且不存在IE兼容性的问题，且拥有和原生浏览器事件一样的接口，支持事件的冒泡机制。React底层主要对合成事件层做了两件事请：事件委派和自动绑定。事件委派：React并不会把事件处理函数绑定到真实的Dom节点上，而是把所有事件绑定到结构的最外层(或许是document节点？)并使用一个统一的事件监听器，这个事件监听器维持了一个映射用来保存所有事件监听和处理函数，组件挂载、卸载时就在这个监听器里添加或删除一些对象。事件触发时，先被这个统一的事件监听器处理，然后在映射里找到真正的处理函数并调用。对于冒泡事件，冒泡到document节点上才会触发，非冒泡事件，在捕获时触发。自动绑定：在React组件里的每个方法的上下文都指向组件的实例，但是在使用ES6 class或者函数组件时，这种绑定就不复存在了，需要手动绑定。 22、React组件中做事件代理的原理？答：同上 23、介绍this各种情况？答：1、事件监听处理函数里的this指向触发事件的Dom节点。2、函数调用时，函数里的this指向它的调用者。3、ES6 class里的this指向class的实例。4、箭头函数里的this，在定义时确定，this也就是它的上下文5、非严格模式下，this指向window,严格模式下 this等于undefined。 24、前端怎么控制管理路由？答：以React的SPA来举例，基于浏览器的history对象来实现的，监听URL的改变，将新的URL生成location对象，加入到history stack 里实现路由跳转。 25、使⽤路由时出现问题如何解决？未知 26、React怎么做数据的检查和变化？暂无","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://tsailor.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Redux请求中间件如何处理并发操作？","slug":"Redux请求中间件如何处理并发操作","date":"2020-09-17T16:00:00.000Z","updated":"2021-08-20T07:42:26.917Z","comments":true,"path":"2020/09/18/Redux请求中间件如何处理并发操作/","link":"","permalink":"http://tsailor.github.io/2020/09/18/Redux%E8%AF%B7%E6%B1%82%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/","excerpt":"Redux请求中间件如何处理并发操作？问题提出背景：有一个数组A，然后让你根据数组A的每一项发起一个请求，拿到所有项的返回结果后，组装起来渲染视图 思路：利用redux-thunk中间件来操作，redux-thunk使得 dispatch()得到增强，能接收一个函数，在这个函数里使用promise.all()执行完异步操作后，再dispatch一个action对象。","text":"Redux请求中间件如何处理并发操作？问题提出背景：有一个数组A，然后让你根据数组A的每一项发起一个请求，拿到所有项的返回结果后，组装起来渲染视图 思路：利用redux-thunk中间件来操作，redux-thunk使得 dispatch()得到增强，能接收一个函数，在这个函数里使用promise.all()执行完异步操作后，再dispatch一个action对象。 12345678910111213141516171819202122232425262728//App.jsimport React from 'react';import &#123;connect&#125; from 'react-redux';import &#123; getLists&#125; from './reducer';import &#123; requestLists &#125; from './action';function App(props)&#123; const value = [\"user01\",\"user02\",\"user03\"] // 假设列表测试数据 const &#123; lists, requestLists &#125; = props; const handleClick = (value)=&gt;&#123; requestLists(value) &#125; return( &lt;div&gt; &lt;button onClick = &#123;()=&gt;handleClick(value)&#125;&gt;点击获取列表view &lt;/button&gt; &#123; lists &amp;&amp; lists.map((list) =&gt;(&lt;li key=&#123;list.name&#125;&gt;&#123;list.name&#125;&lt;/li&gt;))&#125; &lt;/div&gt; )&#125;const mapStateToProps = (state) =&gt;(&#123; lists:getLists(state)&#125;)const mapDispatchToProps = (dispatch) =&gt;(&#123; requestLists: requestLists(dispatch)&#125;)export default connect( mapStateToProps, mapDispatchToProps)(App); 再来看看 action.js 12345678910111213141516171819// action.jsimport axios from \"axios\";const requreAllLists = (value) =&gt;(dispatch)=&gt;&#123; // 这个dispatch是applyMiddlewares传递进去的增强后的dispatch axios.all( value.map((v)=&gt;&#123; // 并发 return axios.get(`/users`,&#123; params: &#123; ID: v &#125;&#125;) &#125;)).then(axios.spread(function (...args) &#123; let data = args.map((v)=&gt;v.data) dispatch(&#123; type: \"RECELIVED_ALL\", data // 这里就是将所有返回结果送至store &#125;) &#125;));&#125;export const requestLists = (dispatch) =&gt;(value)=&gt;&#123; dispatch(requreAllLists(value)) // redux-thunk能接收异步函数&#125; 再新建一个server.js服务,用来处理响应 123456789101112131415161718const Koa = require('Koa');const Router = require('koa-router')const &#123; URL &#125; = require('url');const app = new Koa();const router = new Router();let base = 'http://localhost:4000/';router.get('/',async ctx =&gt;&#123; ctx.body = \"hello, ok\"&#125;)router.get('/users',async ctx =&gt;&#123; let myUrl = new URL( ctx.url, base ); //console.log(myUrl.searchParams.get(\"ID\")) let id = myUrl.searchParams.get(\"ID\") ctx.body = \"name\"+id&#125;)app.use(router.routes())app.listen(4000)","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://tsailor.github.io/tags/React/"}]},{"title":"React长列表优化：虚拟列表(一)","slug":"React长列表优化：虚拟列表(一)","date":"2020-08-23T16:00:00.000Z","updated":"2021-08-20T09:15:39.295Z","comments":true,"path":"2020/08/24/React长列表优化：虚拟列表(一)/","link":"","permalink":"http://tsailor.github.io/2020/08/24/React%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8(%E4%B8%80)/","excerpt":"React长列表优化：虚拟列表(一)单条表单高度固定的长列表，虚拟滚动 步骤1：新建server.js 返回10000+条数据 1234const Koa = require(\"koa\");const Router = require('koa-router'); //路由模块const app = new Koa();const router = new Router();","text":"React长列表优化：虚拟列表(一)单条表单高度固定的长列表，虚拟滚动 步骤1：新建server.js 返回10000+条数据 1234const Koa = require(\"koa\");const Router = require('koa-router'); //路由模块const app = new Koa();const router = new Router(); 1234567891011121314151617181920212223242526272829router.get('/api/getMock',async ctx =&gt;&#123; let list = []; function getRandomWords(n) &#123; let words1 = \"但使龙城飞将在，不教胡马度阴山0123456789\"; let ret = ''; let len = words1.length; for (let i = 0; i &lt; n; i++) &#123; ret += words1[Math.floor(Math.random() * len)] &#125; return ret; &#125; for (let i = 0; i &lt; 10000; i++) &#123; list.push(&#123; title: getRandomWords(12), id: `id-$&#123;i&#125;`, &#125;) &#125; ctx.body = &#123; state: 200, data: list &#125;&#125;)router.get('/test',async ctx=&gt;&#123; ctx.body=\"ok\"&#125;)app.use(router.routes());app.listen(8080) 步骤2：接受后端数据,并传入到子组件 12345678910111213const useData = ()=&gt;&#123; return fetch('/api/getMock').then(res=&gt;res.json())&#125;function App()&#123; let getListData = useData(); const [ listDatas, setListDatas ] = useState([]); // 所有数据 useEffect(()=&gt;&#123; getListData.then(res=&gt;setListDatas(res.data)) &#125;,[]) return( listDatas.length!==0 ? &lt;VirtualList lists=&#123;listDatas&#125; vitemHeight=&#123;50&#125;/&gt; : &lt;div&gt;正在加载ing...&lt;/div&gt; )&#125; 步骤3：子组件布局 12345678910111213141516171819202122232425262728293031323334353637&lt;div className=\"list-view\" ref = &#123;listView&#125; &gt; &lt;div className=\"list-view-plantom\" style=&#123;&#123;height : `$&#123;totalLength*itemHeight&#125;px`&#125;&#125;&gt;&lt;/div&gt; &lt;div className=\"list-content\" ref = &#123;listContent&#125;&gt; &#123;visibleData.map((item) =&gt; &lt;LiItem item=&#123;item&#125; itemHeight=&#123;itemHeight&#125; key=&#123;item.id&#125;/&gt;)&#125; &lt;/div&gt;&lt;/div&gt;.list-view &#123; margin-top: 100px; width: 400px; height: 600px; border: 1px solid lightgray; overflow-y: auto; position: relative; &#125;.list-view-plantom &#123; position: absolute; left: 0; top: 0; right: 0; z-index: -1;&#125;.list-content &#123; left: 0; right: 0; top: 0; bottom: 0; position: absolute;&#125;.list-items &#123; width: 100%; vertical-align: middle; text-align: center; list-style: none; border-bottom:1px solid black;&#125; 解释一下：最外层容器相对定位，里面一个plantom使用绝对定位并把高度设定为lists.length * itemHeight，使最外层容器出现滚动。里层的content容器绝对定位避免频繁的回流与重绘。步骤3：VirtuaList组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344const Li = (props) =&gt;&#123; let &#123; item,itemHeight &#125; = props; return &lt;li className=\"list-items\" style=&#123;&#123; lineHeight:`$&#123;itemHeight&#125;px` , height:`$&#123;itemHeight&#125;px`&#125;&#125; &gt;&#123;item.title&#125;&lt;/li&gt;&#125;const LiItem = React.memo((props)=&gt;&lt;Li &#123;...props&#125;/&gt;); // 避免不必要渲染const VirtualList = (props)=&gt;&#123; let &#123;lists, vitemHeight&#125; = props; let totalLength = lists.length; // 总list长度 const listView = useRef(null); const listContent = useRef(null); let [visibleData, setVisibledata ] = useState([]); let itemHeight = vitemHeight|| 50; // 每个listItem 高度 let buffreSize = 5; const updateVisible = (scrollTop)=&gt;&#123; let curScrollTop = scrollTop || 0; // console.log(listContent.current.clientHeight) let visibleCount = Math.ceil( listView.current.clientHeight / itemHeight); let start = Math.floor(curScrollTop/itemHeight); let end = start + visibleCount + buffreSize; setVisibledata(lists.slice(start, end)); // 重新获取数据 listContent.current.style.transform = `translate3d(0, $&#123;start *itemHeight&#125;px,0)`; // content始终保证在可视区域 &#125; const handleScrol = (e)=&gt;&#123; const curScrollTop = listView.current.scrollTop; updateVisible(curScrollTop) &#125; useEffect(()=&gt;&#123; updateVisible(); listView.current.addEventListener(\"scroll\",handleScrol) return ()=&gt;listView.current.removeEventListener(\"scroll\", handleScrol) &#125;,[]) return( &lt;div className=\"list-view\" ref = &#123;listView&#125; &gt; &lt;div className=\"list-view-plantom\" style=&#123;&#123;height : `$&#123;totalLength*itemHeight&#125;px`&#125;&#125;&gt;&lt;/div&gt; &lt;div className=\"list-content\" ref = &#123;listContent&#125;&gt; &#123;visibleData.map((item) =&gt; &lt;LiItem item=&#123;item&#125; itemHeight=&#123;itemHeight&#125; key=&#123;item.id&#125;/&gt;)&#125; &lt;/div&gt; &lt;/div&gt; )&#125; 参考：再谈前端虚拟列表的实现react-tiny-virtual-list目前这个还很粗鄙，后续还会发布更多的版本the end","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://tsailor.github.io/tags/React/"}]},{"title":"React长列表优化：懒加载+分页","slug":"React长列表优化：懒加载+分页","date":"2020-08-20T16:00:00.000Z","updated":"2021-08-20T09:17:09.784Z","comments":true,"path":"2020/08/21/React长列表优化：懒加载+分页/","link":"","permalink":"http://tsailor.github.io/2020/08/21/React%E9%95%BF%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD+%E5%88%86%E9%A1%B5/","excerpt":"React长列表优化：懒加载+分页背景：React项目中渲染一个长列表，后端返回10000+条数据。如果全部渲染出来，耗时即长，长时间白屏。使用懒加载+分页的方式，每次滚动到底部，加载下一页数据。","text":"React长列表优化：懒加载+分页背景：React项目中渲染一个长列表，后端返回10000+条数据。如果全部渲染出来，耗时即长，长时间白屏。使用懒加载+分页的方式，每次滚动到底部，加载下一页数据。 步骤1：启动一个后台服务，返回10000条数据，这里用koa.js来做 12345678910111213141516171819202122232425262728293031const Koa = require(\"koa\");const Router = require('koa-router'); //路由模块const app = new Koa();const router = new Router();router.get('/api/getMock',async ctx =&gt;&#123; let list = []; function getRandomWords(n) &#123; let words1 = \"但使龙城飞将在，不教胡马度阴山0123456789\"; let ret = ''; let len = words1.length; for (let i = 0; i &lt; n; i++) &#123; ret += words1[Math.floor(Math.random() * len)] &#125; return ret; &#125; for (let i = 0; i &lt; 100000; i++) &#123; list.push(&#123; title: getRandomWords(12), id: `id-$&#123;i&#125;`, &#125;) &#125; ctx.body = &#123; state: 200, data: list &#125;&#125;)router.get('/test',async ctx=&gt;&#123; ctx.body=\"ok\"&#125;)app.use(router.routes());app.listen(8080) 由于React项目是以服务的方式启动的，所以配置package.json，添加&quot;proxy&quot;: &quot;http://localhost:8080&quot; 或者使用CORS跨域来做,二选一即可 12345678910111213141516const cors = require('koa2-cors'); //跨域处理app.use( cors(&#123; origin: function(ctx) &#123; //设置允许来自指定域名请求 if (ctx.url === '/test') &#123; return '*'; // 允许来自所有域名请求 &#125; return 'http://localhost:3000'; //只允许http://localhost:3000这个域名的请求 &#125;, // credentials: true, //是否允许发送Cookie allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'], //设置所允许的HTTP请求方法 allowHeaders: ['Content-Type', 'Authorization', 'Accept'], //设置服务器支持的所有头信息字段 exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'] //设置获取其他自定义字段' &#125;)); 步骤2：App.js里使用useState() 将所有的数据放入state 1234567891011121314151617181920212223242526const usedata = ()=&gt;&#123; return fetch('/api/getMock').then(res =&gt; res.json()) // return fetch('http://localhost:8080/api/getMock').then(res =&gt; res.json()) CORS跨域&#125;function App() &#123; let [list, setList ] = useState([]); // 全部数据 let [page, setPage ] = useState(1); // 第一次展示 第一页的数据 let getData = usedata(); useEffect(()=&gt;&#123; // 第一次挂载的时候，请求数据 getData.then(res=&gt;&#123; setList(res.data) &#125;) &#125;,[]) const getNextPage = ()=&gt;&#123; setPage((preState)=&gt;preState+1) &#125; return ( &lt;div className=\"App\"&gt; &lt;div className=\"title\"&gt;长列表优化：懒加载+分页&lt;/div&gt; &#123;list.length!== 0 ? &lt;List data = &#123;list.slice(0,page*20)&#125; handleNextPage=&#123;getNextPage&#125; curPage =&#123;page&#125;/&gt; :null&#125; &lt;/div&gt; );&#125; 步骤3：List组件，防抖优化 1234567891011121314151617181920212223242526272829303132333435363738394041const List = (props) =&gt; &#123; let &#123; data, handleNextPage, curPage &#125; = props; useEffect(()=&gt;&#123; document.querySelector(\".App\").addEventListener(\"scroll\", debounce(fn, 300)); return ()=&gt;document.querySelector(\".App\").removeEventListener(\"scroll\",debounce(fn, 300)) &#125;,[data]) function debounce(fn, wait)&#123; // 防抖 。 非立即执行版本 let timer; return function(...args)&#123; let context = this; if(timer) clearTimeout(timer) timer = setTimeout( ()=&gt;fn.call(context,...args) , wait ) &#125; &#125; function fn()&#123; // const maxScrollTop = document.querySelector(\".App\").scrollHeight // const innerHeight= document.querySelector(\".App\").offsetHeight; const currentScrollTop = document.querySelector(\".App\").scrollTop; // 滚动元素上面超出的距离 const maxScrollTop = document.querySelector(\".App\").scrollHeight - document.querySelector(\".App\").offsetHeight; // 滚动页面长度 - 此容器高度 = 滚动元素上面超出的距离 + 底部未出现的高度 if (maxScrollTop - currentScrollTop &lt; 20) &#123; handleNextPage() // 请求下一页 &#125; &#125; return ( &lt;div className=\"list-panel\"&gt; &#123; data.map((list)=&gt;&lt;Li key=&#123;list.id&#125; list=&#123;list&#125; /&gt;) &#125; &lt;/div&gt; ) &#125; const LiItem = (&#123;list&#125;)=&gt;&lt;li className=\"listitem\" &gt;&#123;list.title&#125;&lt;/li&gt;const Li = React.memo( LiItem ) // React.memo包裹子组件，避免不必要的渲染 总结：此案例中用到了前端用到了 React hooks 、防抖、懒加载、React.memo(), 后台用到了koa.js CORS跨域。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://tsailor.github.io/tags/React/"}]},{"title":"React Redux中关于state的设计的一点思考,","slug":"React Redux中关于state的设计的一点思考","date":"2020-08-17T16:00:00.000Z","updated":"2021-08-20T07:42:26.913Z","comments":true,"path":"2020/08/18/React Redux中关于state的设计的一点思考/","link":"","permalink":"http://tsailor.github.io/2020/08/18/React%20Redux%E4%B8%AD%E5%85%B3%E4%BA%8Estate%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","excerpt":"React Redux中关于state的设计的一点思考Redux应用执行过程中任何一个时刻本质上都是该时刻的应用state的反映，state驱动了Redux的逻辑运转。现在以一个购物车的小案例做分析。https://github.com/Tsailor/web-Practice/tree/master/Redux%E5%AE%9E%E7%8E%B0Shoppping-Cart/shoppingcart内容截图如下","text":"React Redux中关于state的设计的一点思考Redux应用执行过程中任何一个时刻本质上都是该时刻的应用state的反映，state驱动了Redux的逻辑运转。现在以一个购物车的小案例做分析。https://github.com/Tsailor/web-Practice/tree/master/Redux%E5%AE%9E%E7%8E%B0Shoppping-Cart/shoppingcart内容截图如下 整体分为两个部分：商品栏、购物车栏；商品栏：标题、价格、库存量( title, price, inventory );购物车栏：标题、价格、数量、小计金额( title , price, quality , unitPrice);先看一个错误的state设计用例 1234567891011121314&#123; // 全局state products:[ // 商品栏state， 数组表示 &#123;\"id\": 1, \"title\": \"iPad 4 Mini\", \"price\": 500.01, \"inventory\": 2&#125;, &#123;\"id\": 2, \"title\": \"H&amp;M T-Shirt White\", \"price\": 10.99, \"inventory\": 10&#125;, &#123;\"id\": 3, \"title\": \"Charli XCX - Sucker CD\", \"price\": 19.99, \"inventory\": 5&#125; ] carts:&#123; cartProducts:[ &#123;\"id\": 1, \"title\": \"iPad 4 Mini\", \"price\": 500.01, \"quanlity\": 1, \"unitPrice\" : 500.01&#125;, &#123;\"id\": 2, \"title\": \"H&amp;M T-Shirt White\", \"price\": 10.99, \"quanlity\": 1, \"unitPrice\" : 10.99&#125;, ], total:511.00 &#125;&#125; 这样设计的存在问题：1、大量数据重复存储，如id,title,price等2、触发事件Add To Cart时，需要修改的不止一个地方并且需要遍历products和cartProducts中的所有数据根据id进行比较。 存储浪费且性能消耗。 ####该如何合理设计state呢 #### 记住一句话：像设计数据库一样设计state。把state看做一个数据库，state中每一部分状态看做数据库里的一张表，状态中的每一个字段对应表中的一个字段。设计数据库遵循的三个原则：（1）数据按照不同的领域(domain)分类存放在不同的表中，不同表中存储的数据不能重复（2）表中每一列的数据都依赖这张表的主键（3）表中除了主键，其他列互相不能有直接依赖关系于是，根据这三个原则，翻译出设计state时的原则： (1) 整个应用状态按照领域划分若干个子状态，子状态不能保存重复的数据(2) state以键值对的形式保存数据，以记录的key或id作为索引，记录中其他字段都依赖于这个索引(3) state中不能保存可以通过其他字段计算得出的数据，即state中的数据不能相互依赖 重新设计state 1234567891011121314151617&#123; products:&#123; // 分析：按照领域划分子状态， 子状态products byId: &#123; // 键值对的形式保存数据 id/key 作为索引 1: &#123;\"id\": 1, \"title\": \"iPad 4 Mini\", \"price\": 500.01, \"inventory\": 2&#125;, 2: &#123;\"id\": 2, \"title\": \"H&amp;M T-Shirt White\", \"price\": 10.99, \"inventory\": 10&#125;, 3: &#123;\"id\": 3, \"title\": \"Charli XCX - Sucker CD\", \"price\": 19.99, \"inventory\": 5&#125; &#125; containId:[1,2,3] // state包含的key &#125; cart:&#123; // 子状态 carts addedGoodId：[1,2] // 保存添加到购物车的商品的 id 没有重复数据 quantityById: &#123; // 保存每个商品的数量， id作为key 1: 1, 2: 1 &#125; &#125;&#125; 分析：1、按照领域划分子状态，products 和 cart, 不同表中数据不能重复2、state以键值对的形式保存数据，id/key作为索引3、state中的数据不能相互依赖，小计金额可以通过price x quantity得出，不需要存放在state中，total同理。4、商品栏数据通过 containId.map((id) =&gt; byId[ id] )取出。5、触发事件Add To Cart时，products.byTd[ id ].inventory - 1, addedGoodId没有这个id则加入。quantityById 没有这个id则加入id作为属性，value = 1，有则value + 1 The End我还是一个初学者，有不足之处请见谅","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://tsailor.github.io/tags/React/"}]},{"title":"React高阶组件与参数传递","slug":"React高阶组件与参数传递","date":"2020-08-10T16:00:00.000Z","updated":"2021-08-20T07:42:26.916Z","comments":true,"path":"2020/08/11/React高阶组件与参数传递/","link":"","permalink":"http://tsailor.github.io/2020/08/11/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/","excerpt":"React高阶组件与参数传递高阶组件是React中的重要概念，主要用来实现组件逻辑的抽象和复用。高阶组件（简称HOC） 接收React组件作为参数，返回一个新的组件，高阶组件本质上是一个函数。 实例1，写一个高阶组价，用来打印自身的props：","text":"React高阶组件与参数传递高阶组件是React中的重要概念，主要用来实现组件逻辑的抽象和复用。高阶组件（简称HOC） 接收React组件作为参数，返回一个新的组件，高阶组件本质上是一个函数。 实例1，写一个高阶组价，用来打印自身的props： 1234567891011121314151617181920212223242526272829303132333435 import React , &#123; Component &#125; from 'react';function Com()&#123; let data = &#123; name : \"jack\", age : 18 &#125; return( &lt;WithLogProps value=&#123;data&#125;/&gt; )&#125;const MyComponent = (props)=&gt;&#123; return( &lt;div&gt; 我的名字：&#123;props.value.name&#125; 我的年龄：&#123;props.value.age&#125; &lt;/div&gt; )&#125;const WithProps = (MyComponent)=&gt;&#123; return class extends Component &#123; componentDidMount()&#123; console.log(this.props) // 为组件添加事件，打印props &#125; render()&#123; return( &lt; MyComponent &#123;...this.props&#125;/&gt; ) &#125; &#125;&#125;// WithProps是一个高阶组件, 但本质是个函数， WithLogProps 对应的就是 return 的那个组件。通过this.props拿到组件的value属性const WithLogProps = WithProps(MyComponent) export default Com; 有时候也需要接受其他的参数。 1234567891011121314151617181920212223242526272829303132333435363738import React , &#123; Component &#125; from 'react';function Com()&#123; let data = &#123; name : \"jack\", age : 18 &#125; return( &lt;WithLogProps value=&#123;data&#125;/&gt; )&#125;let data = \"Tsailor\"const MyComponent = (props)=&gt;&#123; console.log(props) return( &lt;div&gt; 我的名字：&#123;props.value.name&#125; 我的年龄：&#123;props.value.age&#125; 我的data :&#123;props.data&#125; &lt;/div&gt; )&#125;const WithProps = (data)=&gt; (MyComponent)=&gt;&#123; // 箭头函数自动return return class extends Component &#123; componentDidMount()&#123; console.log(data) // 拿到这个data console.log(this.props) &#125; render()&#123; return( &lt; MyComponent &#123;...this.props&#125; data=&#123;data&#125;/&gt; ) &#125; &#125;&#125;const WithLogProps = WithProps(data)(MyComponent)export default Com;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://tsailor.github.io/tags/React/"}]},{"title":"DOM操作-获取标签数目","slug":"DOM操作-获取标签的数目","date":"2020-07-22T16:00:00.000Z","updated":"2021-08-20T09:17:51.500Z","comments":true,"path":"2020/07/23/DOM操作-获取标签的数目/","link":"","permalink":"http://tsailor.github.io/2020/07/23/DOM%E6%93%8D%E4%BD%9C-%E8%8E%B7%E5%8F%96%E6%A0%87%E7%AD%BE%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"完成一个 getTags 函数，可以检测当前页面用到了哪些标签，函数返回包含标签的字符串的数组，比如页面如下 1234567&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 知识回顾：nodeType === 1 表示元素节点nodeType === 2 表示属性节点 document.documentElement 表示根节点","text":"完成一个 getTags 函数，可以检测当前页面用到了哪些标签，函数返回包含标签的字符串的数组，比如页面如下 1234567&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 知识回顾：nodeType === 1 表示元素节点nodeType === 2 表示属性节点 document.documentElement 表示根节点 12345678910111213let map = &#123;&#125;;let getTags = function(node)&#123; if( node.nodeType != 1) return; let tagsName = node.nodeName; map[tagsName] = ( map[tagsName] ? map[tagsName]++ : 1 ) for(let i = 0; i &lt; node.childNodes.length; i++)&#123; getTags( node.childNodes[i] ) &#125;&#125;getTags(document.documentElement);console.log(map.values)","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://tsailor.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"Git分支管理","slug":"Git分支管理","date":"2020-07-22T16:00:00.000Z","updated":"2021-08-20T07:42:26.911Z","comments":true,"path":"2020/07/23/Git分支管理/","link":"","permalink":"http://tsailor.github.io/2020/07/23/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","excerpt":"1、git创建本地分支：git branch [name]2、git删除本地分支：git branch -d [name]3、git切换分支：git checkout [name]4、git创建并切换到新的本地分支：git checkout -b [name]5、git查看所有分支信息：git branch -a","text":"1、git创建本地分支：git branch [name]2、git删除本地分支：git branch -d [name]3、git切换分支：git checkout [name]4、git创建并切换到新的本地分支：git checkout -b [name]5、git查看所有分支信息：git branch -a 123*master :本地分支， * 当前所在分支 hexo ：本地hexo分支 remotes&#x2F;origin&#x2F;hexo ： 远程分支 6、git创建远程分支：git push origin [name] (将本地新建的分支推送到远程)7、git删除远程分支：git push origin --delete [name]8、本地分支与远程分支建立关联：git branch --set-upstream-to remotes/origin/hexo 实例：将本地hexo分支的内容推送到远程hexo分支1、新建并切换到本地hexo分支 ：git branch hexo2、将本地分支推送到远程分支：git push origin hexo3、本地分支与远程分支关联： git branch --set-upstream-to remotes/origin/hexo4、本地代码提交到版本库：git add . git commit -m &quot;message&quot;5、拉取远程分支内容：git pull origin hexo6、本地代码提交到远程分支：git push origin hexo","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"http://tsailor.github.io/tags/tools/"},{"name":"git","slug":"git","permalink":"http://tsailor.github.io/tags/git/"}]},{"title":"webpack搭建React开发环境","slug":"webpack创建React开发环境","date":"2020-07-21T16:00:00.000Z","updated":"2021-08-20T09:14:35.260Z","comments":true,"path":"2020/07/22/webpack创建React开发环境/","link":"","permalink":"http://tsailor.github.io/2020/07/22/webpack%E5%88%9B%E5%BB%BAReact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"1 webpack搭建react项目以前总是使用脚手架工具直接创建，今天试试webpack手动创建react 项目 1、 新建src 文件夹存放react代码 mkdir src2、 初始化项目 npm init -y3、 安装webpack npm i webpack webpack-cli -devwebpack和babel在打包的时候不会包括到源码里，所以是 - div系统提示说：”-dev”已经不推荐使用了，使用 “–only=dev”代替webpack-cli 包含了许多webpack的指令。","text":"1 webpack搭建react项目以前总是使用脚手架工具直接创建，今天试试webpack手动创建react 项目 1、 新建src 文件夹存放react代码 mkdir src2、 初始化项目 npm init -y3、 安装webpack npm i webpack webpack-cli -devwebpack和babel在打包的时候不会包括到源码里，所以是 - div系统提示说：”-dev”已经不推荐使用了，使用 “–only=dev”代替webpack-cli 包含了许多webpack的指令。 4、 安装babelnpm install @babel/core babel-loader @babel/preset-env @babel/preset-react --only=dev@babel/core 这是babel的核心库@babel/preset-env 将es6编译成es5@babel/preset-react 识别JSX语法babel-loader 将经过babel处理后的文件输出成浏览器可以识别的格式 5、 配置babel，根目录下新建.babelrc文件写入{ &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;] }6、 配置webpack, 新建 webpack.config.js 1234567891011121314151617181920const path = require('path'); //引入路径module.exports = &#123; // 导出 entry: './src/main.js', // 项目入口 output: &#123; // 输出 filename: 'bundle.js', // 打包后的名字 path: path.resolve(__dirname, 'dist') // 当前路径下 &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, // 打包 .js文件 exclude: /node_modules/, use: &#123; loader: \"babel-loader\" // 使用 babel-loader &#125; &#125; ] &#125;&#125;; 7、解析HTML文件，webpack的默认配置只能解析.js文件。安装 html-webpack-pluginjavascript npm i html-webpack-plugin --only=dev再配置插件 1234567const HtmlWebpackPlugin = require('html-webpack-plugin') // 引入plugins: [ new HtmlWebpackPlugin(&#123; title: 'load-files', template: 'index.html' // 模板 &#125;)] 8、安装react、react-domnpm install react react-dom --save 9、 安装，启动webpack-dev-servernpm install webpack-dev-server --save-devpackage.json中，scripts标签里加入 1\"start:dev\": \"webpack-dev-server\" 10、执行npm run start:dev11、打包命令，npx webpack12、 配置解析css的loader ,npm install --save-dev css-loader style-loader顺序先下后上 123456789 [ &#123; loader: 'style-loader' &#125;, // 将style插入到模板里 &#123; loader: 'css-loader', // 解析css options: &#123; modules: true &#125; &#125;] 13、抽离css样式到独立的文件javascript npm install --save-dev mini-css-extract-plugin 配置参照npm文档 1const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); plugins里面加入 1plugins: [new MiniCssExtractPlugin()], 修改rules 中的css-loader 123456rules: [ &#123; test: &#x2F;\\.css$&#x2F;i, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;], &#125;, ],","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"http://tsailor.github.io/tags/tools/"},{"name":"webpack","slug":"webpack","permalink":"http://tsailor.github.io/tags/webpack/"}]},{"title":"JS数组去重的多种方式比较","slug":"JS数组去重的多种方式比较","date":"2020-07-19T16:00:00.000Z","updated":"2021-08-20T07:42:26.913Z","comments":true,"path":"2020/07/20/JS数组去重的多种方式比较/","link":"","permalink":"http://tsailor.github.io/2020/07/20/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/","excerpt":"1、双重for循环 时间复杂度（O^2）,所有方式中时间开销最大。仅仅去除数组中的基本类型元素（不包含 NaN,NaN!==NaN）。 1234567891011function distinct(arr)&#123; for(let i=0;i&lt;arr.length;i++)&#123; for(let j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]===arr[i])&#123; arr.splice(j,1); j--; &#125; &#125; &#125; return arr;&#125;","text":"1、双重for循环 时间复杂度（O^2）,所有方式中时间开销最大。仅仅去除数组中的基本类型元素（不包含 NaN,NaN!==NaN）。 1234567891011function distinct(arr)&#123; for(let i=0;i&lt;arr.length;i++)&#123; for(let j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]===arr[i])&#123; arr.splice(j,1); j--; &#125; &#125; &#125; return arr;&#125; 测试样例 123var arr1=[1,2,2,3,\"a\",\"d\",\"s\",\"a \",\"s\",\"1\",null,null,undefined,undefined,NaN,NaN,new String(\"name\"),new String(\"name\")];var res1=distinct(arr1);console.log(res1); //[1, 2, 3, \"a\", \"d\", \"s\", \"1\", null , undefined, NaN, NaN, String, String] 总结：NaN和Object不能去重 2、Array.filter()和indexOf() Array.filter():为每个元素执行一次callback，将返回所有结果为true的数组元素创建的新的数组。Array.indexOf():返回数组中第一次出现该元素的索引 思路：比较元素在数组中第一次出现的位置（索引）和自身的位置（索引）是否相等，不等则重复。 123456function distinct(arr)&#123; var res=arr.filter((ele,index)=&gt;&#123; return arr.indexOf(ele)===index; &#125;); return res;&#125; 测试样例： 123var arr1=[1,2,2,3,\"a\",\"d\",\"s\",\"a\",\"s\",\"1\",null,null,undefined,undefined,NaN,NaN,new String(\"name\"),new String(\"name\")];var res1=distinct(arr1);console.log(res1); // [1, 2, 3, \"a\", \"d\", \"s\", \"1\", null, unde fined， String, String]arr1.indexOf(NaN); // -1 indexOf 找不到NaN 因为 NaN!==NaN 总结：NaN丢失，Object不去重3、ES6 Set去重 Array.from()：方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例 123function distinct(arr)&#123; return Array.from(new Set(arr));&#125; 测试样例： 123var arr1=[1,2,2,3,\"a\",\"d\",\"s\",\"a\",\"s\",\"1\",null,null,undefined,undefined,NaN,NaN,new String(\"name\"),new String(\"name\")];var res1=distinct(arr1);console.log(res1); // [1, 2 , 3, \"a\", \"d\", \"s\", \"1\", null, undefined, NaN, String, String] 总结：Object不能去重4、Object键值对 12345678function distinct(arr)&#123; let obj=&#123;&#125;; var res=arr.filter(function(ele,index,arr)&#123; //对象只能用字符串作 key,所以转为 字符串。 // 1 和 \"1\" 转 为字符串后相等，为了避免 加上类型 return obj.hasOwnProperty (typeof ele + ele)? false : obj[typeof ele + ele]=true; &#125;) return res;&#125; 测试样例： 123var arr1&#x3D;[1,2,2,3,&quot;a&quot;,&quot;d&quot;,&quot;s&quot;,&quot;a&quot;,&quot;s&quot;,&quot;1&quot;,null,null,undefined,undefined,NaN,NaN,new String(&quot;name&quot;),new String(&quot;name&quot;)];var res1&#x3D;distinct(arr1);console.log(res1); &#x2F;&#x2F; [1, 2 , 3, &quot;a&quot;, &quot;d&quot;, &quot;s&quot;, &quot;1&quot;, null, undefined, NaN, String] 总结：全部去重","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://tsailor.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"JS手动实现new","slug":"JS手动实现new","date":"2020-06-29T16:00:00.000Z","updated":"2021-08-20T07:42:26.912Z","comments":true,"path":"2020/06/30/JS手动实现new/","link":"","permalink":"http://tsailor.github.io/2020/06/30/JS%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0new/","excerpt":"new 构造函数()执行顺序1、在堆内存开辟对象内存空间，命名为obj;2、在obj中添加proto属性，指向 构造函数.prototype;3、更改this指向，将构造函数内的this指向obj;4、执行构造函数内语句；5、若构造函数内没有return或者没有return this、return基本数据类型的值，则返回obj在堆内存中地址;若return引用类型，则返回这个引用类型。 12345678function Person(name,age)&#123; this.name=name; this.age=age; return 12;&#125;var per=new Person(\"jack\",18);console.log(per); //Person &#123; name: \"jack\", age: 18&#125;","text":"new 构造函数()执行顺序1、在堆内存开辟对象内存空间，命名为obj;2、在obj中添加proto属性，指向 构造函数.prototype;3、更改this指向，将构造函数内的this指向obj;4、执行构造函数内语句；5、若构造函数内没有return或者没有return this、return基本数据类型的值，则返回obj在堆内存中地址;若return引用类型，则返回这个引用类型。 12345678function Person(name,age)&#123; this.name=name; this.age=age; return 12;&#125;var per=new Person(\"jack\",18);console.log(per); //Person &#123; name: \"jack\", age: 18&#125; return 基本数据类型时，return语句无意义 1234567function Person(name,age)&#123; this.name=name; this.age=age; return &#123;name:\"TangM\"&#125;;&#125;var per=new Person(\"jack\",18);console.log(per); // &#123;name: \"TangM\"&#125; return引用类型，则返回这个引用类型,相等于 new失效。 手动实现 new 1234567891011121314151617function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.address=\"beijing\"; function Create(Con,...args)&#123; //Create=&gt;new let obj=&#123;&#125;; //开辟obj内存空间 Object.setPrototypeOf(obj,Con.prototype);//添加obj原型执行 构造函数的原型对象 result保存的是构造函数的返回值 let result=Con.apply( obj,args) //更改this指向obj 并执行构造函数内语句 return result instanceof Object ? result：obj;&#125;var per=new Person(\"jack\",18);console.log(per); //Person &#123;name: \"jack\", age: 18&#125;console.log(per.address); // beijingvar _per=Create(Person,\"jack\",18);console.log(_per); //Person &#123;name: \"jack\", age: 18&#125;console.log(_per.address ); //// beijing result保存的是构造函数的返回值，如果返回值是一个对象则返回这个值，否则返回obj","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://tsailor.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"JS深拷贝与浅拷贝","slug":"JS深拷贝与浅拷贝","date":"2020-06-25T16:00:00.000Z","updated":"2021-08-20T07:42:26.913Z","comments":true,"path":"2020/06/26/JS深拷贝与浅拷贝/","link":"","permalink":"http://tsailor.github.io/2020/06/26/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"JS数据类型划分：基本数据类型：string,number,boolean,null,undefined引用数据类型：Object(包括 Array,String,Function,Math,Date等) JS内存分为堆（heap）和栈（stack）栈：由系统自动分配，自动回收，效率高，但容量小。堆：由程序员手动分配内存，并且手动销毁（高级语言如JS中有垃圾自动回收机制），效率不如栈，但容量大。 JS的基本类型分配在栈中。","text":"JS数据类型划分：基本数据类型：string,number,boolean,null,undefined引用数据类型：Object(包括 Array,String,Function,Math,Date等) JS内存分为堆（heap）和栈（stack）栈：由系统自动分配，自动回收，效率高，但容量小。堆：由程序员手动分配内存，并且手动销毁（高级语言如JS中有垃圾自动回收机制），效率不如栈，但容量大。 JS的基本类型分配在栈中。 而因为引用类型大小的不固定，系统将存储该引用类型的地址存在栈中，并赋值给变量本身，而具体的内容存在堆中。所以当访问一个对象的时候，先访问栈中它的地址，然后按照这个地址去堆中找到它的实际内容。 当复制的时候，对于基本类型的变量，系统会为新的变量在栈中开辟一个新的空间，赋予相同的值，然后这两个变量就各自独立，毫无牵连。而对于引用类型的变量，新的变量复制的是那个对象在堆中的地址，这两个变量指向的是同一个对象。 JS的基本类型不存在浅拷贝还是深拷贝的问题，主要是针对于对象，比如一般的对象，和特殊的数组对象。 浅拷贝是指复制对象的时候，指对第一层键值对进行独立的复制。 浅拷贝实现方式1： 123456789101112131415function shaCopy(source)&#123; //浅拷贝 var target=&#123;&#125;; if(!source||typeof source!== \"Object\") return; for(var key in source)&#123; target[key]=source[key]; &#125; return target;&#125;var a=&#123; name:\"jack\", age:18 &#125;;var res=shaCopy(a);console.log(res); // &#123;name: \"jack\", age: 18&#125;res.age=20;console.log(a); // &#123;name: \"jack\", age: 18&#125;console.log(res); // &#123;name: \"jack\", age: 20&#125; 浅拷贝实现方式2： Object.assign是ES6的新函数。Object.assign()方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 1Object.assign(target, ...sources) 参数： target：目标对象。sources：任意多个源对象。返回值：目标对象会被返回。 123456var obj1=&#123; name:\"jack\", friend:&#123; name:\"tom\",age:18 &#125;&#125;;var res1=Object.assign(&#123;&#125;,obj1);console.log(res1) | // &#123; name:\"jack\", friend:&#123; name:\"tom\",age:18 &#125;&#125; //但是修改res1中friend对应的属性，obj1中friend对应的属性也会改变res1.friend. |name=\"lili\";console.log(obj1); // &#123; name:\"jack\", friend:&#123; name:\"lili\",age:18 &#125;&#125; 那如何完全独立地拷贝出一份呢？这也就是所谓的深拷贝。 深拷贝实现方式1： Object.assign();当对象只有一层时，Object.assign()也能实现深拷贝。 深拷贝实现方式2：用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。 但是只有对象内属性值不为undefined和Function时可用。 深拷贝实现方式3：递归实现 12345678910111213141516171819202122232425262728293031323334function deepClone(source) &#123; var target = &#123;&#125;; if (!source ||typeof source !== \"object\") return; for (var key in source) &#123; var value = source[key]; if (typeof value === 'object') &#123; //属性值是数组或对象 target[key] = deepClone(value) &#125; else &#123; target[key]= value; &#125; &#125;; return target;&#125;; var obj1 = &#123; name: \"jake\", friend: &#123; name: \"Tom\", address: &#123; city: \"Beijing\" &#125; &#125;&#125;;var res1=deepClone(obj1); res1.friend.address.city = \"ShangHai\"; //属性值为对象console.log(res1); // &#123; name: \"jake\", friend: &#123;name: \"Tom\", address: &#123; city: \"ShangHai\" &#125;&#125;&#125;; console.log(obj1); // &#123; name:\"jake\",friend: &#123; name: \"Tom\", address: &#123; city: \"Beijing\"&#125;&#125;&#125;;//属性值为数组var obj2=&#123; name:\"jake\",friend:[ 13,24,[19,20,18] ]&#125;; var res2 = deepClone(obj2); res2.friend[2][1] = 0; console.log(res2); // &#123; name: \"jake\", friend: [13, 24, [19, 0, 18]]&#125;; console.log(obj2); // &#123; name:\"jake\",friend:[ 13,24,[19,20,18] ]&#125;; 深拷贝实现方式4：jquery 有提供一个$.extend可以用来做 Deep Copy。 1234var $ = require('jquery');var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;var obj2 = $.extend(true, &#123;&#125;, obj1);console.log(obj1.b.f === obj2.b.f);// false 深拷贝实现方式5：另外一个很热门的函数库lodash，也有提供_.cloneDeep用来做 Deep Copy。 1234var _ = require('lodash');var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;var obj2 = _.cloneDeep(obj1);console.log(obj1.b.f === obj2.b.f);","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://tsailor.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-31T16:00:00.000Z","updated":"2021-08-20T07:42:26.917Z","comments":true,"path":"2020/06/01/hello-world/","link":"","permalink":"http://tsailor.github.io/2020/06/01/hello-world/","excerpt":"","text":"以前的blog不慎丢失了，从今开始，记录学习过程","categories":[],"tags":[]}]