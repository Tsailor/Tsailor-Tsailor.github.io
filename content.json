[{"title":"React Redux中关于state的设计的一点思考,","slug":"React Redux中关于state的设计的一点思考","date":"2020-08-17T16:00:00.000Z","updated":"2020-08-18T03:26:51.080Z","comments":true,"path":"2020/08/18/React Redux中关于state的设计的一点思考/","link":"","permalink":"http://yoursite.com/2020/08/18/React%20Redux%E4%B8%AD%E5%85%B3%E4%BA%8Estate%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","excerpt":"React Redux中关于state的设计的一点思考Redux应用执行过程中任何一个时刻本质上都是该时刻的应用state的反映，state驱动了Redux的逻辑运转。现在以一个购物车的小案例做分析。https://github.com/Tsailor/web-Practice/tree/master/Redux%E5%AE%9E%E7%8E%B0Shoppping-Cart/shoppingcart内容截图如下","text":"React Redux中关于state的设计的一点思考Redux应用执行过程中任何一个时刻本质上都是该时刻的应用state的反映，state驱动了Redux的逻辑运转。现在以一个购物车的小案例做分析。https://github.com/Tsailor/web-Practice/tree/master/Redux%E5%AE%9E%E7%8E%B0Shoppping-Cart/shoppingcart内容截图如下 整体分为两个部分：商品栏、购物车栏；商品栏：标题、价格、库存量( title, price, inventory );购物车栏：标题、价格、数量、小计金额( title , price, quality , unitPrice);先看一个错误的state设计用例 1234567891011121314&#123; // 全局state products:[ // 商品栏state， 数组表示 &#123;\"id\": 1, \"title\": \"iPad 4 Mini\", \"price\": 500.01, \"inventory\": 2&#125;, &#123;\"id\": 2, \"title\": \"H&amp;M T-Shirt White\", \"price\": 10.99, \"inventory\": 10&#125;, &#123;\"id\": 3, \"title\": \"Charli XCX - Sucker CD\", \"price\": 19.99, \"inventory\": 5&#125; ] carts:&#123; cartProducts:[ &#123;\"id\": 1, \"title\": \"iPad 4 Mini\", \"price\": 500.01, \"quanlity\": 1, \"unitPrice\" : 500.01&#125;, &#123;\"id\": 2, \"title\": \"H&amp;M T-Shirt White\", \"price\": 10.99, \"quanlity\": 1, \"unitPrice\" : 10.99&#125;, ], total:511.00 &#125;&#125; 这样设计的存在问题：1、大量数据重复存储，如id,title,price等2、触发事件Add To Cart时，需要修改的不止一个地方并且需要遍历products和cartProducts中的所有数据根据id进行比较。 存储浪费且性能消耗。 ####该如何合理设计state呢 #### 记住一句话：像设计数据库一样设计state。把state看做一个数据库，state中每一部分状态看做数据库里的一张表，状态中的每一个字段对应表中的一个字段。设计数据库遵循的三个原则：（1）数据按照不同的领域(domain)分类存放在不同的表中，不同表中存储的数据不能重复（2）表中每一列的数据都依赖这张表的主键（3）表中除了主键，其他列互相不能有直接依赖关系于是，根据这三个原则，翻译出设计state时的原则： (1) 整个应用状态按照领域划分若干个子状态，子状态不能保存重复的数据(2) state以键值对的形式保存数据，以记录的key或id作为索引，记录中其他字段都依赖于这个索引(3) state中不能保存可以通过其他字段计算得出的数据，即state中的数据不能相互依赖 重新设计state 1234567891011121314151617&#123; products:&#123; // 分析：按照领域划分子状态， 子状态products byId: &#123; // 键值对的形式保存数据 id/key 作为索引 1: &#123;\"id\": 1, \"title\": \"iPad 4 Mini\", \"price\": 500.01, \"inventory\": 2&#125;, 2: &#123;\"id\": 2, \"title\": \"H&amp;M T-Shirt White\", \"price\": 10.99, \"inventory\": 10&#125;, 3: &#123;\"id\": 3, \"title\": \"Charli XCX - Sucker CD\", \"price\": 19.99, \"inventory\": 5&#125; &#125; containId:[1,2,3] // state包含的key &#125; cart:&#123; // 子状态 carts addedGoodId：[1,2] // 保存添加到购物车的商品的 id 没有重复数据 quantityById: &#123; // 保存每个商品的数量， id作为key 1: 1, 2: 1 &#125; &#125;&#125; 分析：1、按照领域划分子状态，products 和 cart, 不同表中数据不能重复2、state以键值对的形式保存数据，id/key作为索引3、state中的数据不能相互依赖，小计金额可以通过price x quantity得出，不需要存放在state中，total同理。4、商品栏数据通过 containId.map((id) =&gt; byId[ id] )取出。5、触发事件Add To Cart时，products.byTd[ id ].inventory - 1, addedGoodId没有这个id则加入。quantityById 没有这个id则加入id作为属性，value = 1，有则value + 1 The End我还是一个初学者，有不足之处请见谅","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React高阶组件与参数传递","slug":"React高阶组件与参数传递","date":"2020-08-10T16:00:00.000Z","updated":"2020-08-18T03:02:53.945Z","comments":true,"path":"2020/08/11/React高阶组件与参数传递/","link":"","permalink":"http://yoursite.com/2020/08/11/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/","excerpt":"React高阶组件与参数传递高阶组件是React中的重要概念，主要用来实现组件逻辑的抽象和复用。高阶组件（简称HOC） 接收React组件作为参数，返回一个新的组件，高阶组件本质上是一个函数。 实例1，写一个高阶组价，用来打印自身的props：","text":"React高阶组件与参数传递高阶组件是React中的重要概念，主要用来实现组件逻辑的抽象和复用。高阶组件（简称HOC） 接收React组件作为参数，返回一个新的组件，高阶组件本质上是一个函数。 实例1，写一个高阶组价，用来打印自身的props： 1234567891011121314151617181920212223242526272829303132333435 import React , &#123; Component &#125; from 'react';function Com()&#123; let data = &#123; name : \"jack\", age : 18 &#125; return( &lt;WithLogProps value=&#123;data&#125;/&gt; )&#125;const MyComponent = (props)=&gt;&#123; return( &lt;div&gt; 我的名字：&#123;props.value.name&#125; 我的年龄：&#123;props.value.age&#125; &lt;/div&gt; )&#125;const WithProps = (MyComponent)=&gt;&#123; return class extends Component &#123; componentDidMount()&#123; console.log(this.props) // 为组件添加事件，打印props &#125; render()&#123; return( &lt; MyComponent &#123;...this.props&#125;/&gt; ) &#125; &#125;&#125;// WithProps是一个高阶组件, 但本质是个函数， WithLogProps 对应的就是 return 的那个组件。通过this.props拿到组件的value属性const WithLogProps = WithProps(MyComponent) export default Com; 有时候也需要接受其他的参数。 1234567891011121314151617181920212223242526272829303132333435363738import React , &#123; Component &#125; from 'react';function Com()&#123; let data = &#123; name : \"jack\", age : 18 &#125; return( &lt;WithLogProps value=&#123;data&#125;/&gt; )&#125;let data = \"Tsailor\"const MyComponent = (props)=&gt;&#123; console.log(props) return( &lt;div&gt; 我的名字：&#123;props.value.name&#125; 我的年龄：&#123;props.value.age&#125; 我的data :&#123;props.data&#125; &lt;/div&gt; )&#125;const WithProps = (data)=&gt; (MyComponent)=&gt;&#123; // 箭头函数自动return return class extends Component &#123; componentDidMount()&#123; console.log(data) // 拿到这个data console.log(this.props) &#125; render()&#123; return( &lt; MyComponent &#123;...this.props&#125; data=&#123;data&#125;/&gt; ) &#125; &#125;&#125;const WithLogProps = WithProps(data)(MyComponent)export default Com;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"DOM操作-获取标签数目","slug":"DOM操作-获取标签的数目","date":"2020-07-22T16:00:00.000Z","updated":"2020-08-11T16:05:09.347Z","comments":true,"path":"2020/07/23/DOM操作-获取标签的数目/","link":"","permalink":"http://yoursite.com/2020/07/23/DOM%E6%93%8D%E4%BD%9C-%E8%8E%B7%E5%8F%96%E6%A0%87%E7%AD%BE%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"完成一个 getTags 函数，可以检测当前页面用到了哪些标签，函数返回包含标签的字符串的数组，比如页面如下 1234567&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 知识回顾：nodeType === 1 表示元素节点nodeType === 2 表示属性节点 document.documentElement 表示根节点","text":"完成一个 getTags 函数，可以检测当前页面用到了哪些标签，函数返回包含标签的字符串的数组，比如页面如下 1234567&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 知识回顾：nodeType === 1 表示元素节点nodeType === 2 表示属性节点 document.documentElement 表示根节点 12345678910111213let map = &#123;&#125;;let getTags = function(node)&#123; if( node.nodeType != 1) return; let tagsName = node.nodeName; map[tagsName] = ( map[tagsName] ? map[tagsName]++ : 1 ) for(let i = 0; i &lt; node.childNodes.length; i++)&#123; getTags( node.childNodes[i] ) &#125;&#125;getTags(document.documentElement);console.log(map.values)","categories":[],"tags":[{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"Git分支管理","slug":"Git分支管理","date":"2020-07-22T16:00:00.000Z","updated":"2020-08-11T16:05:09.348Z","comments":true,"path":"2020/07/23/Git分支管理/","link":"","permalink":"http://yoursite.com/2020/07/23/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","excerpt":"1、git创建本地分支：git branch [name]2、git删除本地分支：git branch -d [name]3、git切换分支：git checkout [name]4、git创建并切换到新的本地分支：git checkout -b [name]5、git查看所有分支信息：git branch -a","text":"1、git创建本地分支：git branch [name]2、git删除本地分支：git branch -d [name]3、git切换分支：git checkout [name]4、git创建并切换到新的本地分支：git checkout -b [name]5、git查看所有分支信息：git branch -a 123*master :本地分支， * 当前所在分支 hexo ：本地hexo分支 remotes&#x2F;origin&#x2F;hexo ： 远程分支 6、git创建远程分支：git push origin [name] (将本地新建的分支推送到远程)7、git删除远程分支：git push origin --delete [name]8、本地分支与远程分支建立关联：git branch --set-upstream-to remotes/origin/hexo 实例：将本地hexo分支的内容推送到远程hexo分支1、新建并切换到本地hexo分支 ：git branch hexo2、将本地分支推送到远程分支：git push origin hexo3、本地分支与远程分支关联： git branch --set-upstream-to remotes/origin/hexo4、本地代码提交到版本库：git add . git commit -m &quot;message&quot;5、拉取远程分支内容：git pull origin hexo6、本地代码提交到远程分支：git push origin hexo","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"webpack搭建React开发环境","slug":"webpack创建React开发环境","date":"2020-07-21T16:00:00.000Z","updated":"2020-08-18T03:02:53.947Z","comments":true,"path":"2020/07/22/webpack创建React开发环境/","link":"","permalink":"http://yoursite.com/2020/07/22/webpack%E5%88%9B%E5%BB%BAReact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"1 webpack搭建react项目以前总是使用脚手架工具直接创建，今天试试webpack手动创建react 项目 1、 新建src 文件夹存放react代码 mkdir src2、 初始化项目 npm init -y3、 安装webpack npm i webpack webpack-cli -devwebpack和babel在打包的时候不会包括到源码里，所以是 - div系统提示说：”-dev”已经不推荐使用了，使用 “–only=dev”代替webpack-cli 包含了许多webpack的指令。","text":"1 webpack搭建react项目以前总是使用脚手架工具直接创建，今天试试webpack手动创建react 项目 1、 新建src 文件夹存放react代码 mkdir src2、 初始化项目 npm init -y3、 安装webpack npm i webpack webpack-cli -devwebpack和babel在打包的时候不会包括到源码里，所以是 - div系统提示说：”-dev”已经不推荐使用了，使用 “–only=dev”代替webpack-cli 包含了许多webpack的指令。 4、 安装babelnpm install @babel/core babel-loader @babel/preset-env @babel/preset-react --only=dev@babel/core 这是babel的核心库@babel/preset-env 将es6编译成es5@babel/preset-react 识别JSX语法babel-loader 将经过babel处理后的文件输出成浏览器可以识别的格式 5、 配置babel，根目录下新建.babelrc文件写入{ &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;] }6、 配置webpack, 新建 webpack.config.js 1234567891011121314151617181920const path = require('path'); //引入路径module.exports = &#123; // 导出 entry: './src/main.js', // 项目入口 output: &#123; // 输出 filename: 'bundle.js', // 打包后的名字 path: path.resolve(__dirname, 'dist') // 当前路径下 &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, // 打包 .js文件 exclude: /node_modules/, use: &#123; loader: \"babel-loader\" // 使用 babel-loader &#125; &#125; ] &#125;&#125;; 7、解析HTML文件，webpack的默认配置只能解析.js文件。安装 html-webpack-pluginjavascript npm i html-webpack-plugin --only=dev再配置插件 1234567const HtmlWebpackPlugin = require('html-webpack-plugin') // 引入plugins: [ new HtmlWebpackPlugin(&#123; title: 'load-files', template: 'index.html' // 模板 &#125;)] 8、安装react、react-domnpm install react react-dom --save 9、 安装，启动webpack-dev-servernpm install webpack-dev-server --save-devpackage.json中，scripts标签里加入 1\"start:dev\": \"webpack-dev-server\" 10、执行npm run start:dev11、打包命令，npx webpack12、 配置解析css的loader ,npm install --save-dev css-loader style-loader顺序先下后上 123456789 [ &#123; loader: 'style-loader' &#125;, // 将style插入到模板里 &#123; loader: 'css-loader', // 解析css options: &#123;s modules: true &#125; &#125;] 13、抽离css样式到独立的文件javascript npm install --save-dev mini-css-extract-plugin 配置参照npm文档","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"JS数组去重的多种方式比较","slug":"JS数组去重的多种方式比较","date":"2020-07-19T16:00:00.000Z","updated":"2020-07-23T01:52:48.598Z","comments":true,"path":"2020/07/20/JS数组去重的多种方式比较/","link":"","permalink":"http://yoursite.com/2020/07/20/JS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/","excerpt":"1、双重for循环 时间复杂度（O^2）,所有方式中时间开销最大。仅仅去除数组中的基本类型元素（不包含 NaN,NaN!==NaN）。 1234567891011function distinct(arr)&#123; for(let i=0;i&lt;arr.length;i++)&#123; for(let j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]===arr[i])&#123; arr.splice(j,1); j--; &#125; &#125; &#125; return arr;&#125;","text":"1、双重for循环 时间复杂度（O^2）,所有方式中时间开销最大。仅仅去除数组中的基本类型元素（不包含 NaN,NaN!==NaN）。 1234567891011function distinct(arr)&#123; for(let i=0;i&lt;arr.length;i++)&#123; for(let j=i+1;j&lt;arr.length;j++)&#123; if(arr[j]===arr[i])&#123; arr.splice(j,1); j--; &#125; &#125; &#125; return arr;&#125; 测试样例 123var arr1=[1,2,2,3,\"a\",\"d\",\"s\",\"a \",\"s\",\"1\",null,null,undefined,undefined,NaN,NaN,new String(\"name\"),new String(\"name\")];var res1=distinct(arr1);console.log(res1); //[1, 2, 3, \"a\", \"d\", \"s\", \"1\", null , undefined, NaN, NaN, String, String] 总结：NaN和Object不能去重 2、Array.filter()和indexOf() Array.filter():为每个元素执行一次callback，将返回所有结果为true的数组元素创建的新的数组。Array.indexOf():返回数组中第一次出现该元素的索引 思路：比较元素在数组中第一次出现的位置（索引）和自身的位置（索引）是否相等，不等则重复。 123456function distinct(arr)&#123; var res=arr.filter((ele,index)=&gt;&#123; return arr.indexOf(ele)===index; &#125;); return res;&#125; 测试样例： 123var arr1=[1,2,2,3,\"a\",\"d\",\"s\",\"a\",\"s\",\"1\",null,null,undefined,undefined,NaN,NaN,new String(\"name\"),new String(\"name\")];var res1=distinct(arr1);console.log(res1); // [1, 2, 3, \"a\", \"d\", \"s\", \"1\", null, unde fined， String, String]arr1.indexOf(NaN); // -1 indexOf 找不到NaN 因为 NaN!==NaN 总结：NaN丢失，Object不去重3、ES6 Set去重 Array.from()：方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例 123function distinct(arr)&#123; return Array.from(new Set(arr));&#125; 测试样例： 123var arr1=[1,2,2,3,\"a\",\"d\",\"s\",\"a\",\"s\",\"1\",null,null,undefined,undefined,NaN,NaN,new String(\"name\"),new String(\"name\")];var res1=distinct(arr1);console.log(res1); // [1, 2 , 3, \"a\", \"d\", \"s\", \"1\", null, undefined, NaN, String, String] 总结：Object不能去重4、Object键值对 12345678function distinct(arr)&#123; let obj=&#123;&#125;; var res=arr.filter(function(ele,index,arr)&#123; //对象只能用字符串作 key,所以转为 字符串。 // 1 和 \"1\" 转 为字符串后相等，为了避免 加上类型 return obj.hasOwnProperty (typeof ele + ele)? false : obj[typeof ele + ele]=true; &#125;) return res;&#125; 测试样例： 123var arr1&#x3D;[1,2,2,3,&quot;a&quot;,&quot;d&quot;,&quot;s&quot;,&quot;a&quot;,&quot;s&quot;,&quot;1&quot;,null,null,undefined,undefined,NaN,NaN,new String(&quot;name&quot;),new String(&quot;name&quot;)];var res1&#x3D;distinct(arr1);console.log(res1); &#x2F;&#x2F; [1, 2 , 3, &quot;a&quot;, &quot;d&quot;, &quot;s&quot;, &quot;1&quot;, null, undefined, NaN, String] 总结：全部去重","categories":[],"tags":[{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS手动实现new","slug":"JS手动实现new","date":"2020-06-29T16:00:00.000Z","updated":"2020-07-23T01:53:04.966Z","comments":true,"path":"2020/06/30/JS手动实现new/","link":"","permalink":"http://yoursite.com/2020/06/30/JS%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0new/","excerpt":"new 构造函数()执行顺序1、在堆内存开辟对象内存空间，命名为obj;2、在obj中添加proto属性，指向 构造函数.prototype;3、更改this指向，将构造函数内的this指向obj;4、执行构造函数内语句；5、若构造函数内没有return或者没有return this、return基本数据类型的值，则返回obj在堆内存中地址;若return引用类型，则返回这个引用类型。 12345678function Person(name,age)&#123; this.name=name; this.age=age; return 12;&#125;var per=new Person(\"jack\",18);console.log(per); //Person &#123; name: \"jack\", age: 18&#125;","text":"new 构造函数()执行顺序1、在堆内存开辟对象内存空间，命名为obj;2、在obj中添加proto属性，指向 构造函数.prototype;3、更改this指向，将构造函数内的this指向obj;4、执行构造函数内语句；5、若构造函数内没有return或者没有return this、return基本数据类型的值，则返回obj在堆内存中地址;若return引用类型，则返回这个引用类型。 12345678function Person(name,age)&#123; this.name=name; this.age=age; return 12;&#125;var per=new Person(\"jack\",18);console.log(per); //Person &#123; name: \"jack\", age: 18&#125; return 基本数据类型时，return语句无意义 1234567function Person(name,age)&#123; this.name=name; this.age=age; return &#123;name:\"TangM\"&#125;;&#125;var per=new Person(\"jack\",18);console.log(per); // &#123;name: \"TangM\"&#125; return引用类型，则返回这个引用类型,相等于 new失效。 手动实现 new 1234567891011121314151617function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.prototype.address=\"beijing\"; function Create(Con,...args)&#123; //Create=&gt;new let obj=&#123;&#125;; //开辟obj内存空间 Object.setPrototypeOf(obj,Con.prototype);//添加obj原型执行 构造函数的原型对象 result保存的是构造函数的返回值 let result=Con.apply( obj,args) //更改this指向obj 并执行构造函数内语句 return result instanceof Object ? result：obj;&#125;var per=new Person(\"jack\",18);console.log(per); //Person &#123;name: \"jack\", age: 18&#125;console.log(per.address); // beijingvar _per=Create(Person,\"jack\",18);console.log(_per); //Person &#123;name: \"jack\", age: 18&#125;console.log(_per.address ); //// beijing result保存的是构造函数的返回值，如果返回值是一个对象则返回这个值，否则返回obj","categories":[],"tags":[{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"JS深拷贝与浅拷贝","slug":"JS深拷贝与浅拷贝","date":"2020-06-25T16:00:00.000Z","updated":"2020-07-23T02:12:21.288Z","comments":true,"path":"2020/06/26/JS深拷贝与浅拷贝/","link":"","permalink":"http://yoursite.com/2020/06/26/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"JS数据类型划分：基本数据类型：string,number,boolean,null,undefined引用数据类型：Object(包括 Array,String,Function,Math,Date等) JS内存分为堆（heap）和栈（stack）栈：由系统自动分配，自动回收，效率高，但容量小。堆：由程序员手动分配内存，并且手动销毁（高级语言如JS中有垃圾自动回收机制），效率不如栈，但容量大。 JS的基本类型分配在栈中。","text":"JS数据类型划分：基本数据类型：string,number,boolean,null,undefined引用数据类型：Object(包括 Array,String,Function,Math,Date等) JS内存分为堆（heap）和栈（stack）栈：由系统自动分配，自动回收，效率高，但容量小。堆：由程序员手动分配内存，并且手动销毁（高级语言如JS中有垃圾自动回收机制），效率不如栈，但容量大。 JS的基本类型分配在栈中。 而因为引用类型大小的不固定，系统将存储该引用类型的地址存在栈中，并赋值给变量本身，而具体的内容存在堆中。所以当访问一个对象的时候，先访问栈中它的地址，然后按照这个地址去堆中找到它的实际内容。 当复制的时候，对于基本类型的变量，系统会为新的变量在栈中开辟一个新的空间，赋予相同的值，然后这两个变量就各自独立，毫无牵连。而对于引用类型的变量，新的变量复制的是那个对象在堆中的地址，这两个变量指向的是同一个对象。 JS的基本类型不存在浅拷贝还是深拷贝的问题，主要是针对于对象，比如一般的对象，和特殊的数组对象。 浅拷贝是指复制对象的时候，指对第一层键值对进行独立的复制。 浅拷贝实现方式1： 123456789101112131415function shaCopy(source)&#123; //浅拷贝 var target=&#123;&#125;; if(!source||typeof source!== \"Object\") return; for(var key in source)&#123; target[key]=source[key]; &#125; return target;&#125;var a=&#123; name:\"jack\", age:18 &#125;;var res=shaCopy(a);console.log(res); // &#123;name: \"jack\", age: 18&#125;res.age=20;console.log(a); // &#123;name: \"jack\", age: 18&#125;console.log(res); // &#123;name: \"jack\", age: 20&#125; 浅拷贝实现方式2： Object.assign是ES6的新函数。Object.assign()方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 1Object.assign(target, ...sources) 参数： target：目标对象。sources：任意多个源对象。返回值：目标对象会被返回。 123456var obj1=&#123; name:\"jack\", friend:&#123; name:\"tom\",age:18 &#125;&#125;;var res1=Object.assign(&#123;&#125;,obj1);console.log(res1) | // &#123; name:\"jack\", friend:&#123; name:\"tom\",age:18 &#125;&#125; //但是修改res1中friend对应的属性，obj1中friend对应的属性也会改变res1.friend. |name=\"lili\";console.log(obj1); // &#123; name:\"jack\", friend:&#123; name:\"lili\",age:18 &#125;&#125; 那如何完全独立地拷贝出一份呢？这也就是所谓的深拷贝。 深拷贝实现方式1： Object.assign();当对象只有一层时，Object.assign()也能实现深拷贝。 深拷贝实现方式2：用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。 但是只有对象内属性值不为undefined和Function时可用。 深拷贝实现方式3：递归实现 12345678910111213141516171819202122232425262728293031323334function deepClone(source) &#123; var target = &#123;&#125;; if (!source ||typeof source !== \"object\") return; for (var key in source) &#123; var value = source[key]; if (typeof value === 'object') &#123; //属性值是数组或对象 target[key] = deepClone(value) &#125; else &#123; target[key]= value; &#125; &#125;; return target;&#125;; var obj1 = &#123; name: \"jake\", friend: &#123; name: \"Tom\", address: &#123; city: \"Beijing\" &#125; &#125;&#125;;var res1=deepClone(obj1); res1.friend.address.city = \"ShangHai\"; //属性值为对象console.log(res1); // &#123; name: \"jake\", friend: &#123;name: \"Tom\", address: &#123; city: \"ShangHai\" &#125;&#125;&#125;; console.log(obj1); // &#123; name:\"jake\",friend: &#123; name: \"Tom\", address: &#123; city: \"Beijing\"&#125;&#125;&#125;;//属性值为数组var obj2=&#123; name:\"jake\",friend:[ 13,24,[19,20,18] ]&#125;; var res2 = deepClone(obj2); res2.friend[2][1] = 0; console.log(res2); // &#123; name: \"jake\", friend: [13, 24, [19, 0, 18]]&#125;; console.log(obj2); // &#123; name:\"jake\",friend:[ 13,24,[19,20,18] ]&#125;; 深拷贝实现方式4：jquery 有提供一个$.extend可以用来做 Deep Copy。 1234var $ = require('jquery');var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;var obj2 = $.extend(true, &#123;&#125;, obj1);console.log(obj1.b.f === obj2.b.f);// false 深拷贝实现方式5：另外一个很热门的函数库lodash，也有提供_.cloneDeep用来做 Deep Copy。 1234var _ = require('lodash');var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;var obj2 = _.cloneDeep(obj1);console.log(obj1.b.f === obj2.b.f);","categories":[],"tags":[{"name":"JS基础","slug":"JS基础","permalink":"http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-31T16:00:00.000Z","updated":"2020-08-18T03:02:53.946Z","comments":true,"path":"2020/06/01/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/01/hello-world/","excerpt":"","text":"以前的blog不慎丢失了，从今开始，记录学习过程","categories":[],"tags":[]}]